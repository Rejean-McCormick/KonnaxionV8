
# --- Contents of: C:\MonCode\KonnaxionV4\apps\mergeEverySubPy.py ---
import os

def merge_py_files(directory, output_file='merged.txt'):
    with open(output_file, 'w', encoding='utf-8') as out_f:
        for root, dirs, files in os.walk(directory):
            # Exclude __pycache__ and migrations directories
            dirs[:] = [d for d in dirs if d not in ('__pycache__', 'migrations')]
            for file in files:
                # Process only .py files, excluding __init__.py and test files.
                if file.endswith('.py') and file != '__init__.py' and not (file.lower().startswith("test") or file.lower().endswith("_test.py")):
                    file_path = os.path.join(root, file)
                    # Write a header indicating the source file.
                    out_f.write(f"\n# --- Contents of: {file_path} ---\n")
                    try:
                        with open(file_path, 'r', encoding='utf-8') as in_f:
                            out_f.write(in_f.read())
                    except Exception as e:
                        out_f.write(f"# Error reading {file_path}: {e}\n")
                    out_f.write("\n" + "="*80 + "\n")

if __name__ == '__main__':
    path = input("Enter the path to search for .py files: ").strip()
    if os.path.isdir(path):
        merge_py_files(path)
        print("Merging complete. The output is saved in 'merged.txt'.")
    else:
        print("The provided path is not a valid directory.")

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\common\-constants.py ---
"""
common/constants.py

This module centralizes all global constants, default values, and shared strings for the Konnaxion platform.
It is intended to be imported wherever these common values are needed, ensuring consistency and reducing duplication.
"""

# -----------------------------------------------------------------------------
# Versioning
# -----------------------------------------------------------------------------
VERSION = "1.0.0"

# -----------------------------------------------------------------------------
# API Endpoints
# -----------------------------------------------------------------------------
API_BASE_PATH = "/api/v1/"

# -----------------------------------------------------------------------------
# Common Field Lengths
# -----------------------------------------------------------------------------
MAX_CHARFIELD_LENGTH = 255

# -----------------------------------------------------------------------------
# Status Constants
# -----------------------------------------------------------------------------
STATUS_ACTIVE = "active"
STATUS_INACTIVE = "inactive"

# -----------------------------------------------------------------------------
# Date & Time Formats
# -----------------------------------------------------------------------------
DATETIME_FORMAT = "%Y-%m-%d %H:%M:%S"
DATE_FORMAT = "%Y-%m-%d"
TIME_FORMAT = "%H:%M:%S"

# -----------------------------------------------------------------------------
# Error Messages
# -----------------------------------------------------------------------------
ERROR_NOT_FOUND = "The requested resource was not found."
ERROR_PERMISSION_DENIED = "You do not have permission to perform this action."
ERROR_INVALID_REQUEST = "Invalid request. Please check your input."

# -----------------------------------------------------------------------------
# Logging Levels
# -----------------------------------------------------------------------------
LOGGING_LEVEL_DEBUG = "DEBUG"
LOGGING_LEVEL_INFO = "INFO"
LOGGING_LEVEL_WARNING = "WARNING"
LOGGING_LEVEL_ERROR = "ERROR"
LOGGING_LEVEL_CRITICAL = "CRITICAL"

# -----------------------------------------------------------------------------
# Celery & Asynchronous Task Constants
# -----------------------------------------------------------------------------
CELERY_ACCEPT_CONTENT = ['json']
CELERY_TASK_SERIALIZER = 'json'
CELERY_RESULT_SERIALIZER = 'json'

# -----------------------------------------------------------------------------
# Pagination & Related Defaults
# -----------------------------------------------------------------------------
DEFAULT_PAGE_SIZE = 20
MAX_PAGE_SIZE = 100

# -----------------------------------------------------------------------------
# OAuth & JWT Settings
# -----------------------------------------------------------------------------
JWT_ALGORITHM = "HS256"
# JWT expiration in seconds (e.g., 1 hour)
JWT_EXPIRATION_DELTA = 3600  

# -----------------------------------------------------------------------------
# Authentication Settings
# -----------------------------------------------------------------------------
# Reference to the custom user model defined in the konnaxion_core app
AUTH_USER_MODEL = "konnaxion.konnaxion_core.CustomUser"

# -----------------------------------------------------------------------------
# Event-Driven & Signal Naming
# -----------------------------------------------------------------------------
SIGNAL_USER_UPDATED = "user_updated"
SIGNAL_REPUTATION_CHANGED = "reputation_changed"

# -----------------------------------------------------------------------------
# WebSocket Channel Names (for Django Channels or similar)
# -----------------------------------------------------------------------------
CHANNEL_NOTIFICATIONS = "notifications_channel"
CHANNEL_CHAT = "chat_room"

# -----------------------------------------------------------------------------
# Environment Variable Keys
# -----------------------------------------------------------------------------
# These keys should match what is set in your .env files or environment configuration.
ENV_SECRET_KEY = "SECRET_KEY"
ENV_DEBUG = "DEBUG"
ENV_ALLOWED_HOSTS = "ALLOWED_HOSTS"
ENV_DATABASE_URL = "DATABASE_URL"
ENV_CELERY_BROKER_URL = "CELERY_BROKER_URL"
ENV_CELERY_RESULT_BACKEND = "CELERY_RESULT_BACKEND"
ENV_OAUTH_CLIENT_ID = "OAUTH_CLIENT_ID"
ENV_OAUTH_CLIENT_SECRET = "OAUTH_CLIENT_SECRET"
ENV_JWT_SECRET_KEY = "JWT_SECRET_KEY"
ENV_SENTRY_DSN = "SENTRY_DSN"

# -----------------------------------------------------------------------------
# Frontend and Path Variables (Reference for settings.py or manage.py)
# -----------------------------------------------------------------------------
# These paths are typically defined in your settings or management files,
# but are included here for reference.
import os

BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
APPS_DIR = os.path.join(BASE_DIR, "apps")
FRONTEND_DIR = os.path.join(BASE_DIR, "frontend")
CONFIG_DIR = os.path.join(BASE_DIR, "config")
ENV_DIR = os.path.join(BASE_DIR, ".envs")
VENV_DIR = os.path.join(BASE_DIR, ".venv")

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\common\admin.py ---
from django.contrib import admin

class BaseAdmin(admin.ModelAdmin):
    """
    A base ModelAdmin with common configurations such as readonly fields,
    list filters, and search fields.
    """
    readonly_fields = ('created_at', 'updated_at',)
    list_filter = ('created_at', 'updated_at',)
    search_fields = ('id',)

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\common\base_models.py ---
from django.db import models
from django.utils import timezone

class TimeStampedModel(models.Model):
    """
    An abstract base class model that provides self-updating 'created_at' and 'updated_at' fields.
    These fields record when an instance is created and last updated.
    """
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        abstract = True


class SoftDeleteModel(models.Model):
    """
    An abstract base class model that provides a soft delete mechanism.
    Instead of permanently deleting records, they are marked as deleted.
    """
    is_deleted = models.BooleanField(default=False)
    deleted_at = models.DateTimeField(null=True, blank=True)

    def delete(self, using=None, keep_parents=False):
        """
        Override the default delete method to perform a soft delete.
        """
        self.is_deleted = True
        self.deleted_at = timezone.now()
        self.save(update_fields=["is_deleted", "deleted_at"])

    def restore(self):
        """
        Restore a soft-deleted record.
        """
        self.is_deleted = False
        self.deleted_at = None
        self.save(update_fields=["is_deleted", "deleted_at"])

    def hard_delete(self, using=None, keep_parents=False):
        """
        Permanently delete the record from the database.
        """
        super(SoftDeleteModel, self).delete(using=using, keep_parents=keep_parents)

    class Meta:
        abstract = True


class BaseModel(TimeStampedModel, SoftDeleteModel):
    """
    An abstract base model that combines timestamping and soft deletion.
    This model serves as a foundation for all other models in the platform.
    
    Additional hooks for event logging or auditing can be added by overriding the save() method here.
    """
    class Meta:
        abstract = True

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\common\forms.py ---
from django import forms

class BaseForm(forms.ModelForm):
    """
    Base form to be extended by all ModelForms. Adds a common CSS class to each field.
    """
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        for visible in self.visible_fields():
            # Apply a common CSS class to every field widget
            visible.field.widget.attrs.setdefault('class', 'form-control')

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\common\mixins.py ---
from rest_framework.response import Response
from rest_framework import status

class CustomResponseMixin:
    """
    Mixin to standardize API responses.
    """
    def success_response(self, data, message="Success", status_code=status.HTTP_200_OK):
        return Response({"message": message, "data": data}, status=status_code)
    
    def error_response(self, errors, message="Error", status_code=status.HTTP_400_BAD_REQUEST):
        return Response({"message": message, "errors": errors}, status=status_code)

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\common\permissions.py ---
from rest_framework.permissions import BasePermission

class IsOwnerOrReadOnly(BasePermission):
    """
    Custom permission that only allows object owners to edit it.
    """
    def has_object_permission(self, request, view, obj):
        # Allow read-only permissions for any request
        if request.method in ('GET', 'HEAD', 'OPTIONS'):
            return True
        # Write permissions are only allowed to the owner.
        return getattr(obj, 'owner', None) == request.user

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\common\serializers.py ---
from rest_framework import serializers

class BaseSerializer(serializers.ModelSerializer):
    """
    A base serializer that provides common configuration.
    Extend this serializer in your app-specific serializers to inherit shared settings.
    """
    class Meta:
        abstract = True

class TimestampedSerializer(BaseSerializer):
    """
    A mixin serializer that automatically includes read-only created_at and updated_at fields.
    Assumes that the model has these fields.
    """
    created_at = serializers.DateTimeField(read_only=True)
    updated_at = serializers.DateTimeField(read_only=True)

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\common\utils.py ---
def format_datetime(dt, format_str="%Y-%m-%d %H:%M:%S"):
    """
    Utility function to format a datetime object as a string.
    Returns an empty string if dt is None.
    """
    if dt:
        return dt.strftime(format_str)
    return ""

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\ethikos\urls.py ---
# apps/ethikos/urls.py
from django.urls import path, include

urlpatterns = [
    path('home/', include('ethikos.home.urls')),
    path('debate_arena/', include('ethikos.debate_arena.urls')),
    path('stats/', include('ethikos.stats.urls')),
    path('knowledge_base/', include('ethikos.knowledge_base.urls')),
    path('prioritization/', include('ethikos.prioritization.urls')),
    path('resolution/', include('ethikos.resolution.urls')),
]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\ethikos\debate_arena\admin.py ---
# apps/ethikos/debate_arena/admin.py

from django.contrib import admin
from ethikos.debate_arena.models import DebateSession, Argument, VoteRecord

@admin.register(DebateSession)
class DebateSessionAdmin(admin.ModelAdmin):
    list_display = ('topic', 'moderator', 'start_time', 'end_time', 'is_active', 'created_at')
    list_filter = ('is_active', 'moderator')
    search_fields = ('topic', 'description')
    ordering = ('-start_time',)
    
@admin.register(Argument)
class ArgumentAdmin(admin.ModelAdmin):
    list_display = ('short_content', 'debate_session', 'author', 'vote_count', 'created_at')
    list_filter = ('debate_session', 'author')
    search_fields = ('content',)
    ordering = ('-created_at',)

    def short_content(self, obj):
        return (obj.content[:75] + '...') if len(obj.content) > 75 else obj.content
    short_content.short_description = "Argument"

@admin.register(VoteRecord)
class VoteRecordAdmin(admin.ModelAdmin):
    list_display = ('argument', 'voter', 'vote_value', 'timestamp', 'created_at')
    list_filter = ('argument', 'voter')
    ordering = ('-timestamp',)

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\ethikos\debate_arena\apps.py ---
from django.apps import AppConfig

class EthikosDebateArenaConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'ethikos.debate_arena'
    verbose_name = "Ethikos Debate Arena"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\ethikos\debate_arena\forms.py ---

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\ethikos\debate_arena\models.py ---
"""
File: apps/ethikos/debate_arena/models.py

Purpose:
Define models for real‑time debate sessions, including threaded arguments,
vote records, and audit trails.
"""

from django.db import models
from common.base_models import BaseModel

class DebateSession(BaseModel):
    """
    Represents a real-time debate session.
    """
    topic = models.CharField(max_length=255, help_text="Title or topic of the debate session")
    description = models.TextField(null=True, blank=True, help_text="Description of the debate session")
    moderator = models.ForeignKey(
        "core.CustomUser",
        on_delete=models.SET_NULL,
        null=True,
        related_name="moderated_debates",
        help_text="Moderator of the debate session"
    )
    start_time = models.DateTimeField(help_text="Debate start time")
    end_time = models.DateTimeField(null=True, blank=True, help_text="Debate end time")
    is_active = models.BooleanField(default=True, help_text="Indicates if the debate session is active")

    def __str__(self):
        return self.topic

class Argument(BaseModel):
    """
    Represents an argument within a debate session.
    Supports threaded replies.
    """
    debate_session = models.ForeignKey(
        DebateSession,
        on_delete=models.CASCADE,
        related_name="arguments",
        help_text="Debate session this argument belongs to"
    )
    author = models.ForeignKey(
        "core.CustomUser",
        on_delete=models.CASCADE,
        related_name="arguments",
        help_text="User who posted the argument"
    )
    content = models.TextField(help_text="Content of the argument")
    parent = models.ForeignKey(
        'self',
        on_delete=models.CASCADE,
        null=True,
        blank=True,
        related_name="replies",
        help_text="Parent argument for threaded discussions"
    )
    vote_count = models.IntegerField(default=0, help_text="Net vote count for the argument")

    def __str__(self):
        return f"Argument by {self.author} in {self.debate_session.topic}"

class VoteRecord(BaseModel):
    """
    Records a vote on an argument within a debate session.
    """
    argument = models.ForeignKey(
        Argument,
        on_delete=models.CASCADE,
        related_name="vote_records",
        help_text="The argument being voted on"
    )
    voter = models.ForeignKey(
        "core.CustomUser",
        on_delete=models.CASCADE,
        related_name="vote_records",
        help_text="User who cast the vote"
    )
    vote_value = models.IntegerField(help_text="Vote value, e.g., +1 or -1")
    timestamp = models.DateTimeField(auto_now_add=True, help_text="Timestamp when the vote was cast")

    def __str__(self):
        return f"Vote by {self.voter} on Argument {self.argument.id}: {self.vote_value}"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\ethikos\debate_arena\serializers.py ---
from rest_framework import serializers
from ethikos.debate_arena.models import DebateSession, Argument, VoteRecord

class DebateSessionSerializer(serializers.ModelSerializer):
    class Meta:
        model = DebateSession
        fields = [
            'id',
            'topic',
            'description',
            'moderator',
            'start_time',
            'end_time',
            'is_active',
            'created_at',
            'updated_at'
        ]

class ArgumentSerializer(serializers.ModelSerializer):
    # Recursively include replies
    replies = serializers.SerializerMethodField()

    class Meta:
        model = Argument
        fields = [
            'id',
            'debate_session',
            'author',
            'content',
            'parent',
            'vote_count',
            'created_at',
            'updated_at',
            'replies'
        ]

    def get_replies(self, obj):
        qs = obj.replies.all()
        return ArgumentSerializer(qs, many=True).data

class VoteRecordSerializer(serializers.ModelSerializer):
    class Meta:
        model = VoteRecord
        fields = [
            'id',
            'argument',
            'voter',
            'vote_value',
            'timestamp',
            'created_at',
            'updated_at'
        ]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\ethikos\debate_arena\urls.py ---
# apps/ethikos/debate_arena/urls.py
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from ethikos.debate_arena.views import DebateSessionViewSet, ArgumentViewSet, VoteRecordViewSet

router = DefaultRouter()
router.register(r'debate_sessions', DebateSessionViewSet)
router.register(r'arguments', ArgumentViewSet)
router.register(r'vote_records', VoteRecordViewSet)

urlpatterns = [
    path('', include(router.urls)),
]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\ethikos\debate_arena\views.py ---
# apps/ethikos/debate_arena/views.py

from rest_framework import viewsets, permissions, status
from rest_framework.decorators import action
from rest_framework.response import Response

from ethikos.debate_arena.models import DebateSession, Argument, VoteRecord
from ethikos.debate_arena.serializers import (
    DebateSessionSerializer,
    ArgumentSerializer,
    VoteRecordSerializer
)

class DebateSessionViewSet(viewsets.ModelViewSet):
    """
    ViewSet pour gérer les sessions de débat en temps réel.
    """
    queryset = DebateSession.objects.all()
    serializer_class = DebateSessionSerializer
    permission_classes = [permissions.IsAuthenticated]

    @action(detail=True, methods=['post'], permission_classes=[permissions.IsAuthenticated])
    def end_session(self, request, pk=None):
        """
        Action pour clôturer une session de débat.
        Par exemple, en mettant à jour l'état et en enregistrant l'heure de fin.
        """
        session = self.get_object()
        session.is_active = False
        # Vous pouvez utiliser timezone.now() ou accepter une valeur dans request.data
        session.end_time = request.data.get('end_time')
        session.save()
        return Response(self.get_serializer(session).data)

class ArgumentViewSet(viewsets.ModelViewSet):
    """
    ViewSet pour gérer les arguments dans une session de débat.
    """
    queryset = Argument.objects.all()
    serializer_class = ArgumentSerializer
    permission_classes = [permissions.IsAuthenticated]

class VoteRecordViewSet(viewsets.ModelViewSet):
    """
    ViewSet pour gérer l'enregistrement des votes sur les arguments.
    """
    queryset = VoteRecord.objects.all()
    serializer_class = VoteRecordSerializer
    permission_classes = [permissions.IsAuthenticated]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\ethikos\home\admin.py ---
# apps/ethikos/home/admin.py

from django.contrib import admin
from ethikos.home.models import DebateTopic, FeaturedDebate, PersonalizedRecommendation

@admin.register(DebateTopic)
class DebateTopicAdmin(admin.ModelAdmin):
    list_display = ('title', 'is_active', 'publish_date', 'created_at')
    list_filter = ('is_active',)
    search_fields = ('title', 'description')
    ordering = ('title',)

@admin.register(FeaturedDebate)
class FeaturedDebateAdmin(admin.ModelAdmin):
    list_display = ('debate_topic', 'display_order', 'active', 'created_at')
    list_filter = ('active',)
    ordering = ('display_order',)

@admin.register(PersonalizedRecommendation)
class PersonalizedRecommendationAdmin(admin.ModelAdmin):
    list_display = ('user', 'debate_topic', 'score', 'created_at')
    list_filter = ('user',)
    search_fields = ('debate_topic__title',)
    ordering = ('-created_at',)

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\ethikos\home\apps.py ---
from django.apps import AppConfig

class EthikosHomeConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'ethikos.home'
    verbose_name = "Ethikos Home"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\ethikos\home\forms.py ---

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\ethikos\home\models.py ---
"""
File: apps/ethikos/ethikos_home/models.py

Purpose:
Create models for the debate landing portal, storing debate topics, featured items,
and personalized recommendations.
"""

from django.db import models
from common.base_models import BaseModel

class DebateTopic(BaseModel):
    """
    Represents a debate topic or category.
    """
    title = models.CharField(max_length=255, help_text="Title of the debate topic")
    description = models.TextField(help_text="Description of the debate topic")
    is_active = models.BooleanField(default=True, help_text="Whether the debate topic is active")
    publish_date = models.DateTimeField(null=True, blank=True, help_text="Publish date of the topic")

    def __str__(self):
        return self.title

class FeaturedDebate(BaseModel):
    """
    Marks a debate topic as featured on the landing portal.
    """
    debate_topic = models.ForeignKey(
        DebateTopic,
        on_delete=models.CASCADE,
        related_name="featured_entries",
        help_text="Featured debate topic"
    )
    display_order = models.PositiveIntegerField(default=0, help_text="Order for display")
    active = models.BooleanField(default=True, help_text="Whether this featured entry is active")

    def __str__(self):
        return f"Featured: {self.debate_topic.title}"

class PersonalizedRecommendation(BaseModel):
    """
    Stores personalized debate topic recommendations for users.
    """
    user = models.ForeignKey(
        "core.CustomUser",
        on_delete=models.CASCADE,
        related_name="recommendations",
        help_text="User receiving the recommendation"
    )
    debate_topic = models.ForeignKey(
        DebateTopic,
        on_delete=models.CASCADE,
        related_name="recommendations",
        help_text="Recommended debate topic"
    )
    score = models.FloatField(default=0, help_text="Relevance score for the recommendation")

    def __str__(self):
        return f"Recommendation for {self.user}: {self.debate_topic.title}"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\ethikos\home\serializers.py ---
from rest_framework import serializers
from ethikos.home.models import DebateTopic, FeaturedDebate, PersonalizedRecommendation

class DebateTopicSerializer(serializers.ModelSerializer):
    class Meta:
        model = DebateTopic
        fields = [
            'id',
            'title',
            'description',
            'is_active',
            'publish_date',
            'created_at',
            'updated_at'
        ]

class FeaturedDebateSerializer(serializers.ModelSerializer):
    debate_topic = DebateTopicSerializer(read_only=True)

    class Meta:
        model = FeaturedDebate
        fields = [
            'id',
            'debate_topic',
            'display_order',
            'active',
            'created_at',
            'updated_at'
        ]

class PersonalizedRecommendationSerializer(serializers.ModelSerializer):
    debate_topic = DebateTopicSerializer(read_only=True)

    class Meta:
        model = PersonalizedRecommendation
        fields = [
            'id',
            'user',
            'debate_topic',
            'score',
            'created_at',
            'updated_at'
        ]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\ethikos\home\urls.py ---
# apps/ethikos/home/urls.py
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from ethikos.home.views import DebateTopicViewSet, FeaturedDebateViewSet, PersonalizedRecommendationViewSet

router = DefaultRouter()
router.register(r'debate_topics', DebateTopicViewSet)
router.register(r'featured_debates', FeaturedDebateViewSet)
router.register(r'personalized_recommendations', PersonalizedRecommendationViewSet)

urlpatterns = [
    path('', include(router.urls)),
]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\ethikos\home\views.py ---
# apps/ethikos/home/views.py

from rest_framework import viewsets, permissions
from ethikos.home.models import DebateTopic, FeaturedDebate, PersonalizedRecommendation
from ethikos.home.serializers import (
    DebateTopicSerializer,
    FeaturedDebateSerializer,
    PersonalizedRecommendationSerializer
)

class DebateTopicViewSet(viewsets.ModelViewSet):
    """
    ViewSet pour gérer les sujets de débat et catégories affichés sur le portail d'accueil.
    """
    queryset = DebateTopic.objects.all()
    serializer_class = DebateTopicSerializer
    permission_classes = [permissions.IsAuthenticated]

class FeaturedDebateViewSet(viewsets.ModelViewSet):
    """
    ViewSet pour gérer les débats mis en avant sur le portail.
    """
    queryset = FeaturedDebate.objects.all()
    serializer_class = FeaturedDebateSerializer
    permission_classes = [permissions.IsAuthenticated]

class PersonalizedRecommendationViewSet(viewsets.ModelViewSet):
    """
    ViewSet pour gérer les recommandations personnalisées affichées sur le portail.
    """
    queryset = PersonalizedRecommendation.objects.all()
    serializer_class = PersonalizedRecommendationSerializer
    permission_classes = [permissions.IsAuthenticated]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\ethikos\knowledge_base\admin.py ---
# apps/ethikos/knowledge_base/admin.py

from django.contrib import admin
from ethikos.knowledge_base.models import DebateArchive

@admin.register(DebateArchive)
class DebateArchiveAdmin(admin.ModelAdmin):
    list_display = ('title', 'debate_date', 'source', 'created_at')
    list_filter = ('debate_date',)
    search_fields = ('title', 'content')
    ordering = ('-debate_date',)

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\ethikos\knowledge_base\apps.py ---
from django.apps import AppConfig

class EthikosKnowledgeBaseConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'ethikos.knowledge_base'
    verbose_name = "Ethikos Knowledge Base"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\ethikos\knowledge_base\forms.py ---

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\ethikos\knowledge_base\models.py ---
"""
File: apps/ethikos/ethikos_knowledge_base/models.py

This module creates archival models for debates, philosophical texts,
and legal precedents. It supports full‑text search and filtering.
"""

from django.db import models
from common.base_models import BaseModel

class DebateArchive(BaseModel):
    """
    Archives debates and related texts for historical and research purposes.
    """
    title = models.CharField(max_length=255, help_text="Title of the archived debate or text")
    content = models.TextField(help_text="Full text content for search and analysis")
    debate_date = models.DateField(null=True, blank=True, help_text="Date of the debate or publication")
    source = models.CharField(max_length=255, null=True, blank=True, help_text="Source or reference of the material")
    tags = models.JSONField(null=True, blank=True, help_text="List of tags for filtering and search")

    def __str__(self):
        return self.title

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\ethikos\knowledge_base\serializers.py ---
from rest_framework import serializers
from ethikos.knowledge_base.models import DebateArchive

class DebateArchiveSerializer(serializers.ModelSerializer):
    class Meta:
        model = DebateArchive
        fields = [
            'id',
            'title',
            'content',
            'debate_date',
            'source',
            'tags',
            'created_at',
            'updated_at'
        ]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\ethikos\knowledge_base\urls.py ---
# apps/ethikos/knowledge_base/urls.py
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from ethikos.knowledge_base.views import DebateArchiveViewSet

router = DefaultRouter()
router.register(r'debate_archives', DebateArchiveViewSet)

urlpatterns = [
    path('', include(router.urls)),
]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\ethikos\knowledge_base\views.py ---
# apps/ethikos/knowledge_base/views.py

from rest_framework import viewsets, permissions
from ethikos.knowledge_base.models import DebateArchive
from ethikos.knowledge_base.serializers import DebateArchiveSerializer

class DebateArchiveViewSet(viewsets.ModelViewSet):
    """
    ViewSet pour gérer l'archivage des débats et des contenus de référence.
    """
    queryset = DebateArchive.objects.all()
    serializer_class = DebateArchiveSerializer
    permission_classes = [permissions.IsAuthenticated]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\ethikos\prioritization\admin.py ---
# apps/ethikos/prioritization/admin.py

from django.contrib import admin
from ethikos.prioritization.models import DebatePrioritization

@admin.register(DebatePrioritization)
class DebatePrioritizationAdmin(admin.ModelAdmin):
    list_display = ('debate_session', 'ranking_score', 'created_at')
    list_filter = ('debate_session',)
    ordering = ('-created_at',)

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\ethikos\prioritization\apps.py ---
from django.apps import AppConfig

class EthikosPrioritizationConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'ethikos.prioritization'
    verbose_name = "Ethikos Prioritization"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\ethikos\prioritization\forms.py ---

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\ethikos\prioritization\models.py ---
"""
File: apps/ethikos/ethikos_prioritization/models.py

This module develops models to rank and filter debates based on engagement,
credibility, and reputation integration.
"""

from django.db import models
from common.base_models import BaseModel

class DebatePrioritization(BaseModel):
    """
    Ranks a debate session based on computed criteria.
    """
    debate_session = models.ForeignKey(
        "debate_arena.DebateSession",
        on_delete=models.CASCADE,
        related_name="prioritizations",
        help_text="Debate session being ranked"
    )
    ranking_score = models.FloatField(help_text="Computed ranking score for the debate")
    criteria = models.JSONField(null=True, blank=True, help_text="JSON data detailing the ranking criteria")
    notes = models.TextField(null=True, blank=True, help_text="Additional notes or rationale for the ranking")

    def __str__(self):
        return f"Prioritization for {self.debate_session.topic}: Score {self.ranking_score}"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\ethikos\prioritization\serializers.py ---
from rest_framework import serializers
from ethikos.prioritization.models import DebatePrioritization

class DebatePrioritizationSerializer(serializers.ModelSerializer):
    debate_session = serializers.PrimaryKeyRelatedField(read_only=True)

    class Meta:
        model = DebatePrioritization
        fields = [
            'id',
            'debate_session',
            'ranking_score',
            'criteria',
            'notes',
            'created_at',
            'updated_at'
        ]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\ethikos\prioritization\urls.py ---
# apps/ethikos/prioritization/urls.py
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from ethikos.prioritization.views import DebatePrioritizationViewSet

router = DefaultRouter()
router.register(r'debate_prioritizations', DebatePrioritizationViewSet)

urlpatterns = [
    path('', include(router.urls)),
]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\ethikos\prioritization\views.py ---
# apps/ethikos/prioritization/views.py

from rest_framework import viewsets, permissions
from ethikos.prioritization.models import DebatePrioritization
from ethikos.prioritization.serializers import DebatePrioritizationSerializer

class DebatePrioritizationViewSet(viewsets.ModelViewSet):
    """
    ViewSet pour gérer le classement et le filtrage des débats.
    Les critères d'engagement et de crédibilité sont pris en compte dans le score.
    """
    queryset = DebatePrioritization.objects.all()
    serializer_class = DebatePrioritizationSerializer
    permission_classes = [permissions.IsAuthenticated]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\ethikos\resolution\admin.py ---
# apps/ethikos/resolution/admin.py

from django.contrib import admin
from ethikos.resolution.models import DebateResolution

@admin.register(DebateResolution)
class DebateResolutionAdmin(admin.ModelAdmin):
    list_display = ('debate_session', 'approved_by', 'approved_at', 'created_at')
    search_fields = ('debate_session__topic',)
    ordering = ('-approved_at',)

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\ethikos\resolution\apps.py ---
from django.apps import AppConfig

class EthikosResolutionConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'ethikos.resolution'
    verbose_name = "Ethikos Resolution"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\ethikos\resolution\forms.py ---

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\ethikos\resolution\models.py ---
"""
File: apps/ethikos/ethikos_resolution/models.py

This module defines models for documenting final debate resolutions.
It includes detailed decision histories and audit trails.
"""

from django.db import models
from common.base_models import BaseModel

class DebateResolution(BaseModel):
    """
    Documents the final resolution of a debate session.
    """
    debate_session = models.OneToOneField(
        "debate_arena.DebateSession",
        on_delete=models.CASCADE,
        related_name="resolution",
        help_text="Debate session for which this resolution applies"
    )
    resolution_text = models.TextField(help_text="Final resolution details and decisions")
    decision_history = models.JSONField(
        null=True,
        blank=True,
        help_text="JSON record of decision history and audit trail"
    )
    approved_by = models.ForeignKey(
        "core.CustomUser",
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="approved_resolutions",
        help_text="User who approved the resolution"
    )
    approved_at = models.DateTimeField(null=True, blank=True, help_text="Timestamp when the resolution was approved")

    def __str__(self):
        return f"Resolution for {self.debate_session.topic}"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\ethikos\resolution\serializers.py ---
from rest_framework import serializers
from ethikos.resolution.models import DebateResolution

class DebateResolutionSerializer(serializers.ModelSerializer):
    debate_session = serializers.PrimaryKeyRelatedField(read_only=True)
    approved_by = serializers.PrimaryKeyRelatedField(read_only=True)

    class Meta:
        model = DebateResolution
        fields = [
            'id',
            'debate_session',
            'resolution_text',
            'decision_history',
            'approved_by',
            'approved_at',
            'created_at',
            'updated_at'
        ]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\ethikos\resolution\urls.py ---
# apps/ethikos/resolution/urls.py
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from ethikos.resolution.views import DebateResolutionViewSet

router = DefaultRouter()
router.register(r'debate_resolutions', DebateResolutionViewSet)

urlpatterns = [
    path('', include(router.urls)),
]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\ethikos\resolution\views.py ---
# apps/ethikos/resolution/views.py

from rest_framework import viewsets, permissions
from ethikos.resolution.models import DebateResolution
from ethikos.resolution.serializers import DebateResolutionSerializer

class DebateResolutionViewSet(viewsets.ModelViewSet):
    """
    ViewSet pour gérer la documentation des résolutions de débats.
    Chaque résolution inclut l'audit trail complet des décisions.
    """
    queryset = DebateResolution.objects.all()
    serializer_class = DebateResolutionSerializer
    permission_classes = [permissions.IsAuthenticated]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\ethikos\stats\admin.py ---
# apps/ethikos/stats/admin.py

from django.contrib import admin
from ethikos.stats.models import DebateStatistic, DebateEventLog

@admin.register(DebateStatistic)
class DebateStatisticAdmin(admin.ModelAdmin):
    list_display = ('debate_session', 'metric_name', 'value', 'recorded_at')
    list_filter = ('debate_session', 'metric_name')
    ordering = ('-recorded_at',)

@admin.register(DebateEventLog)
class DebateEventLogAdmin(admin.ModelAdmin):
    list_display = ('debate_session', 'event_type', 'timestamp')
    list_filter = ('debate_session', 'event_type')
    ordering = ('-timestamp',)

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\ethikos\stats\apps.py ---
from django.apps import AppConfig

class EthikosStatsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'ethikos.stats'
    verbose_name = "Ethikos Stats"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\ethikos\stats\forms.py ---

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\ethikos\stats\models.py ---
"""
File: apps/ethikos/ethikos_stats/models.py

This module builds models to capture statistical data for debates.
It supports time‑series analytics and logs events for dashboard displays.
"""

from django.db import models
from common.base_models import BaseModel

class DebateStatistic(BaseModel):
    """
    Represents a time-series statistical record for a debate session.
    """
    debate_session = models.ForeignKey(
        "debate_arena.DebateSession",
        on_delete=models.CASCADE,
        related_name="statistics",
        help_text="Associated debate session"
    )
    metric_name = models.CharField(max_length=100, help_text="Name of the metric (e.g., total_votes, active_participants)")
    value = models.FloatField(help_text="Recorded value of the metric")
    recorded_at = models.DateTimeField(auto_now_add=True, help_text="Timestamp when the metric was recorded")

    def __str__(self):
        return f"{self.metric_name} for {self.debate_session.topic}: {self.value}"

class DebateEventLog(BaseModel):
    """
    Logs events related to debates for analytics and audit purposes.
    """
    debate_session = models.ForeignKey(
        "debate_arena.DebateSession",
        on_delete=models.CASCADE,
        related_name="event_logs",
        help_text="Debate session associated with this event"
    )
    event_type = models.CharField(max_length=100, help_text="Type of event (e.g., 'argument_posted', 'vote_cast')")
    description = models.TextField(null=True, blank=True, help_text="Detailed description of the event")
    timestamp = models.DateTimeField(auto_now_add=True, help_text="Timestamp of the event")

    def __str__(self):
        return f"Event {self.event_type} at {self.timestamp}"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\ethikos\stats\serializers.py ---
from rest_framework import serializers
from ethikos.stats.models import DebateStatistic, DebateEventLog

class DebateStatisticSerializer(serializers.ModelSerializer):
    debate_session = serializers.PrimaryKeyRelatedField(read_only=True)

    class Meta:
        model = DebateStatistic
        fields = [
            'id',
            'debate_session',
            'metric_name',
            'value',
            'recorded_at',
            'created_at',
            'updated_at'
        ]

class DebateEventLogSerializer(serializers.ModelSerializer):
    debate_session = serializers.PrimaryKeyRelatedField(read_only=True)

    class Meta:
        model = DebateEventLog
        fields = [
            'id',
            'debate_session',
            'event_type',
            'description',
            'timestamp',
            'created_at',
            'updated_at'
        ]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\ethikos\stats\urls.py ---
# apps/ethikos/stats/urls.py
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from ethikos.stats.views import DebateStatisticViewSet, DebateEventLogViewSet

router = DefaultRouter()
router.register(r'debate_statistics', DebateStatisticViewSet)
router.register(r'debate_event_logs', DebateEventLogViewSet)

urlpatterns = [
    path('', include(router.urls)),
]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\ethikos\stats\views.py ---
# apps/ethikos/stats/views.py

from rest_framework import viewsets, permissions
from ethikos.stats.models import DebateStatistic, DebateEventLog
from ethikos.stats.serializers import DebateStatisticSerializer, DebateEventLogSerializer

class DebateStatisticViewSet(viewsets.ModelViewSet):
    """
    ViewSet pour gérer les statistiques des débats (ex. : nombre de votes, participants actifs).
    """
    queryset = DebateStatistic.objects.all()
    serializer_class = DebateStatisticSerializer
    permission_classes = [permissions.IsAuthenticated]

class DebateEventLogViewSet(viewsets.ModelViewSet):
    """
    ViewSet pour consulter et enregistrer les logs d'événements des débats.
    """
    queryset = DebateEventLog.objects.all()
    serializer_class = DebateEventLogSerializer
    permission_classes = [permissions.IsAuthenticated]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\keenkonnect\urls.py ---
# apps/keenkonnect/urls.py
from django.urls import path, include

urlpatterns = [
    path('projects/', include('keenkonnect.projects.urls')),
    path('gap_analysis/', include('keenkonnect.gap_analysis.urls')),
    path('expert_match/', include('keenkonnect.expert_match.urls')),
    path('team_formation/', include('keenkonnect.team_formation.urls')),
    path('collab_spaces/', include('keenkonnect.collab_spaces.urls')),
    path('knowledge_hub/', include('keenkonnect.knowledge_hub.urls')),
]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\keenkonnect\collab_spaces\admin.py ---
# apps/keenkonnect/collab_spaces/admin.py

from django.contrib import admin
from keenkonnect.collab_spaces.models import CollabSpace, Document, ChatMessage

@admin.register(CollabSpace)
class CollabSpaceAdmin(admin.ModelAdmin):
    list_display = ('name', 'created_by', 'participant_count', 'created_at')
    search_fields = ('name',)
    ordering = ('name',)
    
    def participant_count(self, obj):
        return obj.participants.count()
    participant_count.short_description = "Nombre de participants"

@admin.register(Document)
class DocumentAdmin(admin.ModelAdmin):
    list_display = ('title', 'collab_space', 'uploaded_by', 'uploaded_at')
    list_filter = ('collab_space', 'uploaded_by')
    search_fields = ('title',)
    ordering = ('-uploaded_at',)

@admin.register(ChatMessage)
class ChatMessageAdmin(admin.ModelAdmin):
    list_display = ('collab_space', 'sender', 'is_read', 'created_at')
    list_filter = ('is_read', 'sender')
    search_fields = ('message',)
    ordering = ('-created_at',)
    
    actions = ['mark_messages_as_read']

    def mark_messages_as_read(self, request, queryset):
        updated = queryset.update(is_read=True)
        self.message_user(request, f"{updated} message(s) marqué(s) comme lu(s).")
    mark_messages_as_read.short_description = "Marquer les messages sélectionnés comme lus"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\keenkonnect\collab_spaces\apps.py ---
from django.apps import AppConfig

class KeenkonnectCollabSpacesConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'keenkonnect.collab_spaces'
    verbose_name = "Keenkonnect Collab Spaces"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\keenkonnect\collab_spaces\forms.py ---

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\keenkonnect\collab_spaces\models.py ---
"""
File: \apps\keenkonnect\collab_spaces/models.py

This module defines models for real-time collaboration spaces.
It includes models for collaborative workspaces, document sharing, and chat messages.
"""

from django.db import models
from common.base_models import BaseModel

class CollabSpace(BaseModel):
    """
    Represents a collaborative workspace.
    """
    name = models.CharField(max_length=255, help_text="Name of the collaboration space.")
    description = models.TextField(null=True, blank=True, help_text="Description of the space.")
    created_by = models.ForeignKey(
        "core.CustomUser",
        on_delete=models.SET_NULL,
        null=True,
        related_name="collab_spaces_created",
        help_text="User who created the space."
    )
    participants = models.ManyToManyField(
        "core.CustomUser",
        related_name="collab_spaces",
        help_text="Users participating in the space."
    )
    is_active = models.BooleanField(default=True, help_text="Indicates if the space is active.")

    def __str__(self):
        return self.name

class Document(BaseModel):
    """
    Represents a document shared within a collaboration space.
    """
    collab_space = models.ForeignKey(
        CollabSpace,
        on_delete=models.CASCADE,
        related_name="documents",
        help_text="Collaboration space where the document is shared."
    )
    title = models.CharField(max_length=255, help_text="Title of the document.")
    file = models.FileField(upload_to="collab_documents/", help_text="Uploaded file for the document.")
    description = models.TextField(null=True, blank=True, help_text="Optional description.")
    uploaded_by = models.ForeignKey(
        "core.CustomUser",
        on_delete=models.SET_NULL,
        null=True,
        related_name="uploaded_documents",
        help_text="User who uploaded the document."
    )
    uploaded_at = models.DateTimeField(auto_now_add=True, help_text="Upload timestamp.")

    def __str__(self):
        return self.title

class ChatMessage(BaseModel):
    """
    Represents a chat message within a collaboration space.
    """
    collab_space = models.ForeignKey(
        CollabSpace,
        on_delete=models.CASCADE,
        related_name="chat_messages",
        help_text="Collaboration space where the message was sent."
    )
    sender = models.ForeignKey(
        "core.CustomUser",
        on_delete=models.CASCADE,
        related_name="chat_messages",
        help_text="User who sent the message."
    )
    message = models.TextField(help_text="Content of the chat message.")
    is_read = models.BooleanField(default=False, help_text="Indicates if the message has been read.")

    def __str__(self):
        return f"Message from {self.sender} in {self.collab_space.name}"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\keenkonnect\collab_spaces\serializers.py ---
from rest_framework import serializers
from keenkonnect.collab_spaces.models import CollabSpace, Document, ChatMessage

class CollabSpaceSerializer(serializers.ModelSerializer):
    participants = serializers.PrimaryKeyRelatedField(many=True, read_only=True)

    class Meta:
        model = CollabSpace
        fields = [
            'id',
            'name',
            'description',
            'created_by',
            'participants',
            'is_active',
            'created_at',
            'updated_at'
        ]

class DocumentSerializer(serializers.ModelSerializer):
    collab_space = serializers.PrimaryKeyRelatedField(read_only=True)
    uploaded_by = serializers.PrimaryKeyRelatedField(read_only=True)

    class Meta:
        model = Document
        fields = [
            'id',
            'collab_space',
            'title',
            'file',
            'description',
            'uploaded_by',
            'uploaded_at',
            'created_at',
            'updated_at'
        ]

class ChatMessageSerializer(serializers.ModelSerializer):
    collab_space = serializers.PrimaryKeyRelatedField(read_only=True)
    sender = serializers.PrimaryKeyRelatedField(read_only=True)

    class Meta:
        model = ChatMessage
        fields = [
            'id',
            'collab_space',
            'sender',
            'message',
            'created_at',
            'updated_at'
        ]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\keenkonnect\collab_spaces\urls.py ---
# apps/keenkonnect/collab_spaces/urls.py
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from keenkonnect.collab_spaces.views import CollabSpaceViewSet, DocumentViewSet, ChatMessageViewSet

router = DefaultRouter()
router.register(r'collab_spaces', CollabSpaceViewSet)
router.register(r'documents', DocumentViewSet)
router.register(r'chat_messages', ChatMessageViewSet)

urlpatterns = [
    path('', include(router.urls)),
]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\keenkonnect\collab_spaces\views.py ---
# apps/keenkonnect/collab_spaces/views.py

from rest_framework import viewsets, permissions, status
from rest_framework.decorators import action
from rest_framework.response import Response

from keenkonnect.collab_spaces.models import CollabSpace, Document, ChatMessage
from keenkonnect.collab_spaces.serializers import (
    CollabSpaceSerializer,
    DocumentSerializer,
    ChatMessageSerializer
)
# Exemple : Importer une tâche asynchrone pour notifier les participants en temps réel
# from keenkonnect.collab_spaces.tasks import notify_new_chat_message

class CollabSpaceViewSet(viewsets.ModelViewSet):
    """
    ViewSet pour gérer les espaces de collaboration.
    """
    queryset = CollabSpace.objects.all()
    serializer_class = CollabSpaceSerializer
    permission_classes = [permissions.IsAuthenticated]

    @action(detail=True, methods=['post'], permission_classes=[permissions.IsAuthenticated])
    def add_participant(self, request, pk=None):
        """
        Action personnalisée pour ajouter un participant à un espace de collaboration.
        Attendu : un paramètre 'user_id' dans request.data.
        """
        collab_space = self.get_object()
        user_id = request.data.get('user_id')
        if not user_id:
            return Response({"error": "Le champ 'user_id' est requis."}, status=status.HTTP_400_BAD_REQUEST)
        # On suppose que l'ajout se fait via une méthode add_participant
        try:
            collab_space.participants.add(user_id)
            collab_space.save()
        except Exception as e:
            return Response({"error": str(e)}, status=status.HTTP_400_BAD_REQUEST)
        return Response(self.get_serializer(collab_space).data)

class DocumentViewSet(viewsets.ModelViewSet):
    """
    ViewSet pour gérer les documents partagés dans un espace de collaboration.
    """
    queryset = Document.objects.all()
    serializer_class = DocumentSerializer
    permission_classes = [permissions.IsAuthenticated]

class ChatMessageViewSet(viewsets.ModelViewSet):
    """
    ViewSet pour gérer les messages de chat dans un espace de collaboration.
    """
    queryset = ChatMessage.objects.all()
    serializer_class = ChatMessageSerializer
    permission_classes = [permissions.IsAuthenticated]

    @action(detail=True, methods=['post'], permission_classes=[permissions.IsAuthenticated])
    def mark_as_read(self, request, pk=None):
        """
        Action pour marquer un message de chat comme lu.
        """
        message = self.get_object()
        message.is_read = True
        message.save()
        return Response(self.get_serializer(message).data)

    def perform_create(self, serializer):
        message = serializer.save()
        # Exemple : Déclencher une tâche asynchrone pour notifier les participants du nouvel envoi
        # notify_new_chat_message.delay(message.id)

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\keenkonnect\expert_match\admin.py ---
# apps/keenkonnect/expert_match/admin.py

from django.contrib import admin
from keenkonnect.expert_match.models import ExpertMatchRequest, CandidateProfile, MatchScore

@admin.register(ExpertMatchRequest)
class ExpertMatchRequestAdmin(admin.ModelAdmin):
    list_display = ('project', 'requested_by', 'created_at')
    search_fields = ('project__title', 'requested_by__username')
    ordering = ('-created_at',)
    
    actions = ['trigger_matching']

    def trigger_matching(self, request, queryset):
        # Ici, vous pouvez intégrer un appel à une tâche asynchrone de matching
        count = queryset.count()
        self.message_user(request, f"Processus de matching déclenché pour {count} demande(s).")
    trigger_matching.short_description = "Déclencher le processus de matching pour les demandes sélectionnées"

@admin.register(CandidateProfile)
class CandidateProfileAdmin(admin.ModelAdmin):
    list_display = ('user', 'reputation_score', 'created_at')
    search_fields = ('user__username', 'user__email')
    ordering = ('-created_at',)

@admin.register(MatchScore)
class MatchScoreAdmin(admin.ModelAdmin):
    list_display = ('match_request', 'candidate', 'score', 'created_at')
    search_fields = ('match_request__project__title', 'candidate__user__username')
    ordering = ('-created_at',)

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\keenkonnect\expert_match\apps.py ---
from django.apps import AppConfig

class KeenkonnectExpertMatchConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'keenkonnect.expert_match'
    verbose_name = "Keenkonnect Expert Match"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\keenkonnect\expert_match\forms.py ---

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\keenkonnect\expert_match\models.py ---
"""
File: apps/keenkonnectexpert_match/models.py

This module defines models for matching projects with experts.
It includes models for match requests, candidate profiles, and compatibility scoring.
"""

from django.db import models
from common.base_models import BaseModel

class ExpertMatchRequest(BaseModel):
    """
    Represents a request for expert matching for a project.
    """
    project = models.ForeignKey(
        "projects.Project",
        on_delete=models.CASCADE,
        related_name="expert_match_requests",
        help_text="Project needing expert matching."
    )
    requested_by = models.ForeignKey(
        "core.CustomUser",
        on_delete=models.SET_NULL,
        null=True,
        related_name="expert_match_requests",
        help_text="User who initiated the match request."
    )
    description = models.TextField(help_text="Description of the expertise required.")
    criteria = models.JSONField(null=True, blank=True, help_text="JSON detailing matching criteria.")
    created_at = models.DateTimeField(auto_now_add=True, help_text="Timestamp when the request was created.")

    def __str__(self):
        return f"Expert Match Request for {self.project.title}"

class CandidateProfile(BaseModel):
    """
    Represents a candidate's profile for expert matching.
    """
    user = models.ForeignKey(
        "core.CustomUser",
        on_delete=models.CASCADE,
        related_name="candidate_profiles",
        help_text="User associated with this candidate profile."
    )
    skills = models.JSONField(null=True, blank=True, help_text="JSON data representing skills and expertise.")
    reputation_score = models.FloatField(default=0, help_text="Reputation score from the ekoh system.")

    def __str__(self):
        return f"Candidate Profile for {self.user}"

class MatchScore(BaseModel):
    """
    Represents the compatibility score between a match request and a candidate.
    """
    match_request = models.ForeignKey(
        ExpertMatchRequest,
        on_delete=models.CASCADE,
        related_name="match_scores",
        help_text="The expert match request."
    )
    candidate = models.ForeignKey(
        CandidateProfile,
        on_delete=models.CASCADE,
        related_name="match_scores",
        help_text="Candidate profile being evaluated."
    )
    score = models.FloatField(help_text="Computed compatibility score.")

    def __str__(self):
        return f"Match Score: {self.candidate.user} - {self.score}"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\keenkonnect\expert_match\serializers.py ---
from rest_framework import serializers
from keenkonnect.expert_match.models import ExpertMatchRequest, CandidateProfile, MatchScore

class ExpertMatchRequestSerializer(serializers.ModelSerializer):
    project = serializers.PrimaryKeyRelatedField(read_only=True)
    requested_by = serializers.PrimaryKeyRelatedField(read_only=True)

    class Meta:
        model = ExpertMatchRequest
        fields = [
            'id',
            'project',
            'requested_by',
            'description',
            'criteria',
            'created_at',
            'updated_at'
        ]

class CandidateProfileSerializer(serializers.ModelSerializer):
    user = serializers.PrimaryKeyRelatedField(read_only=True)

    class Meta:
        model = CandidateProfile
        fields = [
            'id',
            'user',
            'skills',
            'reputation_score',
            'created_at',
            'updated_at'
        ]

class MatchScoreSerializer(serializers.ModelSerializer):
    match_request = serializers.PrimaryKeyRelatedField(read_only=True)
    candidate = serializers.PrimaryKeyRelatedField(read_only=True)

    class Meta:
        model = MatchScore
        fields = [
            'id',
            'match_request',
            'candidate',
            'score',
            'created_at',
            'updated_at'
        ]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\keenkonnect\expert_match\urls.py ---
# apps/keenkonnect/expert_match/urls.py
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from keenkonnect.expert_match.views import ExpertMatchRequestViewSet, CandidateProfileViewSet, MatchScoreViewSet

router = DefaultRouter()
router.register(r'expert_match_requests', ExpertMatchRequestViewSet)
router.register(r'candidate_profiles', CandidateProfileViewSet)
router.register(r'match_scores', MatchScoreViewSet)

urlpatterns = [
    path('', include(router.urls)),
]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\keenkonnect\expert_match\views.py ---
# apps/keenkonnect/expert_match/views.py

from rest_framework import viewsets, permissions, status
from rest_framework.decorators import action
from rest_framework.response import Response

from keenkonnect.expert_match.models import ExpertMatchRequest, CandidateProfile, MatchScore
from keenkonnect.expert_match.serializers import (
    ExpertMatchRequestSerializer,
    CandidateProfileSerializer,
    MatchScoreSerializer
)
# Exemple : Importer une tâche asynchrone pour lancer l'algorithme de matching
# from keenkonnect.expert_match.tasks import trigger_expert_matching

class ExpertMatchRequestViewSet(viewsets.ModelViewSet):
    """
    ViewSet pour gérer les demandes de mise en relation avec des experts.
    """
    queryset = ExpertMatchRequest.objects.all()
    serializer_class = ExpertMatchRequestSerializer
    permission_classes = [permissions.IsAuthenticated]

    @action(detail=True, methods=['post'], permission_classes=[permissions.IsAuthenticated])
    def trigger_match(self, request, pk=None):
        """
        Action personnalisée pour déclencher le processus de matching.
        (Ici, vous pouvez appeler une tâche asynchrone par exemple.)
        """
        match_request = self.get_object()
        # Exemple : déclencher la tâche asynchrone
        # trigger_expert_matching.delay(match_request.id)
        return Response({"status": "Matching déclenché", "match_request_id": match_request.id})

class CandidateProfileViewSet(viewsets.ModelViewSet):
    """
    ViewSet pour gérer les profils candidats pour le matching.
    """
    queryset = CandidateProfile.objects.all()
    serializer_class = CandidateProfileSerializer
    permission_classes = [permissions.IsAuthenticated]

class MatchScoreViewSet(viewsets.ModelViewSet):
    """
    ViewSet pour consulter et enregistrer les scores de compatibilité.
    """
    queryset = MatchScore.objects.all()
    serializer_class = MatchScoreSerializer
    permission_classes = [permissions.IsAuthenticated]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\keenkonnect\gap_analysis\admin.py ---
# apps/keenkonnect/gap_analysis/admin.py

from django.contrib import admin
from keenkonnect.gap_analysis.models import GapAnalysis

@admin.register(GapAnalysis)
class GapAnalysisAdmin(admin.ModelAdmin):
    list_display = ('project', 'planned_progress', 'actual_progress', 'gap', 'created_at')
    list_filter = ('project__status',)  # Si le projet possède un champ "status"
    search_fields = ('project__title',)
    ordering = ('-created_at',)

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\keenkonnect\gap_analysis\apps.py ---

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\keenkonnect\gap_analysis\forms.py ---

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\keenkonnect\gap_analysis\models.py ---
"""
File: apps/keenkonnectgap_analysis/models.py

This module defines models to record gap analysis data for projects.
It compares planned versus actual progress and stores recommendations.
"""

from django.db import models
from common.base_models import BaseModel

class GapAnalysis(BaseModel):
    """
    Represents a gap analysis record for a project.
    """
    project = models.ForeignKey(
        "projects.Project",
        on_delete=models.CASCADE,
        related_name="gap_analyses",
        help_text="Project for which the gap analysis is performed."
    )
    planned_progress = models.PositiveIntegerField(help_text="Planned progress percentage.")
    actual_progress = models.PositiveIntegerField(help_text="Actual progress percentage.")
    gap = models.PositiveIntegerField(help_text="Difference between planned and actual progress.")
    recommendations = models.TextField(null=True, blank=True, help_text="Recommendations to close the gap.")

    def __str__(self):
        return f"Gap Analysis for {self.project.title}"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\keenkonnect\gap_analysis\serializers.py ---
from rest_framework import serializers
from keenkonnect.gap_analysis.models import GapAnalysis

class GapAnalysisSerializer(serializers.ModelSerializer):
    project = serializers.PrimaryKeyRelatedField(read_only=True)

    class Meta:
        model = GapAnalysis
        fields = [
            'id',
            'project',
            'planned_progress',
            'actual_progress',
            'gap',
            'recommendations',
            'created_at',
            'updated_at'
        ]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\keenkonnect\gap_analysis\urls.py ---
# apps/keenkonnect/gap_analysis/urls.py
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from keenkonnect.gap_analysis.views import GapAnalysisViewSet

router = DefaultRouter()
router.register(r'gap_analyses', GapAnalysisViewSet)

urlpatterns = [
    path('', include(router.urls)),
]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\keenkonnect\gap_analysis\views.py ---
# apps/keenkonnect/gap_analysis/views.py

from rest_framework import viewsets, permissions
from keenkonnect.gap_analysis.models import GapAnalysis
from keenkonnect.gap_analysis.serializers import GapAnalysisSerializer

class GapAnalysisViewSet(viewsets.ModelViewSet):
    """
    ViewSet pour gérer les enregistrements d'analyse d'écart pour les projets.
    Permet de comparer le progrès prévu et réel et de stocker des recommandations.
    """
    queryset = GapAnalysis.objects.all()
    serializer_class = GapAnalysisSerializer
    permission_classes = [permissions.IsAuthenticated]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\keenkonnect\knowledge_hub\admin.py ---
# apps/keenkonnect/knowledge_hub/admin.py

from django.contrib import admin
from keenkonnect.knowledge_hub.models import KnowledgeDocument, DocumentRevision

class DocumentRevisionInline(admin.TabularInline):
    model = DocumentRevision
    extra = 0
    fields = ('revision_number', 'changes', 'revised_by', 'revised_at')
    readonly_fields = ('revised_at',)

@admin.register(KnowledgeDocument)
class KnowledgeDocumentAdmin(admin.ModelAdmin):
    list_display = ('title', 'version', 'created_by', 'created_at')
    search_fields = ('title', 'description')
    ordering = ('title',)
    inlines = [DocumentRevisionInline]

@admin.register(DocumentRevision)
class DocumentRevisionAdmin(admin.ModelAdmin):
    list_display = ('knowledge_document', 'revision_number', 'revised_by', 'revised_at')
    list_filter = ('knowledge_document',)
    search_fields = ('knowledge_document__title',)
    ordering = ('-revised_at',)

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\keenkonnect\knowledge_hub\apps.py ---
from django.apps import AppConfig

class KeenkonnectKnowledgeHubConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'keenkonnect.knowledge_hub'
    verbose_name = "Keenkonnect Knowledge Hub"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\keenkonnect\knowledge_hub\forms.py ---

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\keenkonnect\knowledge_hub\models.py ---
"""
File: apps/keenkonnect/keenKnowledgeHub/models.py

This module defines models for a repository of blueprints, research documents,
and version-controlled designs.
"""

from django.db import models
from common.base_models import BaseModel

class KnowledgeDocument(BaseModel):
    """
    Represents a document such as a blueprint or research paper.
    """
    title = models.CharField(max_length=255, help_text="Title of the document.")
    description = models.TextField(null=True, blank=True, help_text="Description of the document.")
    document_file = models.FileField(upload_to="knowledge_documents/", help_text="Uploaded document file.")
    version = models.CharField(max_length=50, default="1.0", help_text="Document version.")
    created_by = models.ForeignKey(
        "core.CustomUser",
        on_delete=models.SET_NULL,
        null=True,
        related_name="knowledge_documents",
        help_text="User who created/uploaded the document."
    )

    def __str__(self):
        return f"{self.title} (v{self.version})"

class DocumentRevision(BaseModel):
    """
    Represents a revision of a knowledge document.
    """
    knowledge_document = models.ForeignKey(
        KnowledgeDocument,
        on_delete=models.CASCADE,
        related_name="revisions",
        help_text="The document to which this revision belongs."
    )
    revision_number = models.CharField(max_length=50, help_text="Revision number or identifier.")
    changes = models.TextField(help_text="Description of the changes in this revision.")
    revised_by = models.ForeignKey(
        "core.CustomUser",
        on_delete=models.SET_NULL,
        null=True,
        related_name="document_revisions",
        help_text="User who made the revision."
    )
    revised_at = models.DateTimeField(auto_now_add=True, help_text="Timestamp when the revision was made.")

    def __str__(self):
        return f"{self.knowledge_document.title} Revision {self.revision_number}"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\keenkonnect\knowledge_hub\serializers.py ---
from rest_framework import serializers
from keenkonnect.knowledge_hub.models import KnowledgeDocument, DocumentRevision

class KnowledgeDocumentSerializer(serializers.ModelSerializer):
    class Meta:
        model = KnowledgeDocument
        fields = [
            'id',
            'title',
            'description',
            'document_file',
            'version',
            'created_by',
            'created_at',
            'updated_at'
        ]

class DocumentRevisionSerializer(serializers.ModelSerializer):
    knowledge_document = serializers.PrimaryKeyRelatedField(read_only=True)
    revised_by = serializers.PrimaryKeyRelatedField(read_only=True)

    class Meta:
        model = DocumentRevision
        fields = [
            'id',
            'knowledge_document',
            'revision_number',
            'changes',
            'revised_by',
            'revised_at',
            'created_at',
            'updated_at'
        ]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\keenkonnect\knowledge_hub\urls.py ---
# apps/keenkonnect/knowledge_hub/urls.py
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from keenkonnect.knowledge_hub.views import KnowledgeDocumentViewSet, DocumentRevisionViewSet

router = DefaultRouter()
router.register(r'knowledge_documents', KnowledgeDocumentViewSet)
router.register(r'document_revisions', DocumentRevisionViewSet)

urlpatterns = [
    path('', include(router.urls)),
]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\keenkonnect\knowledge_hub\views.py ---
# apps/keenkonnect/knowledge_hub/views.py

from rest_framework import viewsets, permissions, status
from rest_framework.decorators import action
from rest_framework.response import Response

from keenkonnect.knowledge_hub.models import KnowledgeDocument, DocumentRevision
from keenkonnect.knowledge_hub.serializers import (
    KnowledgeDocumentSerializer,
    DocumentRevisionSerializer
)
# Exemple : Importer une tâche asynchrone pour gérer la révision de document
# from keenkonnect.knowledge_hub.tasks import trigger_document_revision

class KnowledgeDocumentViewSet(viewsets.ModelViewSet):
    """
    ViewSet pour gérer les documents du Knowledge Hub.
    """
    queryset = KnowledgeDocument.objects.all()
    serializer_class = KnowledgeDocumentSerializer
    permission_classes = [permissions.IsAuthenticated]

    @action(detail=True, methods=['post'], permission_classes=[permissions.IsAuthenticated])
    def revise(self, request, pk=None):
        """
        Action personnalisée pour lancer une révision du document.
        """
        document = self.get_object()
        # Exemple : déclencher une tâche asynchrone de révision
        # trigger_document_revision.delay(document.id)
        return Response({"status": "Révision déclenchée", "document_id": document.id})

class DocumentRevisionViewSet(viewsets.ModelViewSet):
    """
    ViewSet pour gérer les révisions des documents.
    """
    queryset = DocumentRevision.objects.all()
    serializer_class = DocumentRevisionSerializer
    permission_classes = [permissions.IsAuthenticated]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\keenkonnect\projects\admin.py ---
# apps/keenkonnect/projects/admin.py

from django.contrib import admin
from keenkonnect.projects.models import Project, Milestone, Task

@admin.register(Project)
class ProjectAdmin(admin.ModelAdmin):
    list_display = ('title', 'owner', 'progress', 'status', 'start_date', 'end_date', 'created_at')
    list_filter = ('status', 'owner')
    search_fields = ('title', 'description')
    ordering = ('title',)
    
    actions = ['mark_as_completed']

    def mark_as_completed(self, request, queryset):
        updated = queryset.update(status='completed')
        self.message_user(request, f"{updated} projet(s) marqué(s) comme terminé(s).")
    mark_as_completed.short_description = "Marquer les projets sélectionnés comme terminés"

@admin.register(Milestone)
class MilestoneAdmin(admin.ModelAdmin):
    list_display = ('title', 'project', 'due_date', 'status', 'created_at')
    list_filter = ('project', 'status')
    search_fields = ('title',)
    ordering = ('project', 'due_date')

@admin.register(Task)
class TaskAdmin(admin.ModelAdmin):
    list_display = ('title', 'milestone', 'assigned_to', 'is_completed', 'created_at')
    list_filter = ('milestone', 'is_completed')
    search_fields = ('title', 'description')
    ordering = ('milestone', 'title')
    
    actions = ['mark_tasks_completed']

    def mark_tasks_completed(self, request, queryset):
        updated = queryset.update(is_completed=True)
        self.message_user(request, f"{updated} tâche(s) marquée(s) comme complétée(s).")
    mark_tasks_completed.short_description = "Marquer les tâches sélectionnées comme complétées"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\keenkonnect\projects\apps.py ---

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\keenkonnect\projects\forms.py ---

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\keenkonnect\projects\models.py ---
"""
File: apps/keenkonnectprojects/models.py

This module manages the project lifecycle. It includes models for Projects,
Milestones, and Tasks for project collaboration and progress tracking.
"""

from django.db import models
from common.base_models import BaseModel

class Project(BaseModel):
    """
    Represents a collaborative project.
    """
    title = models.CharField(max_length=255, help_text="Title of the project.")
    description = models.TextField(help_text="Detailed description of the project.")
    owner = models.ForeignKey(
        "core.CustomUser",
        on_delete=models.SET_NULL,
        null=True,
        related_name="owned_projects",
        help_text="User who created/owns the project."
    )
    progress = models.PositiveIntegerField(default=0, help_text="Progress percentage (0-100) of the project.")
    start_date = models.DateField(null=True, blank=True, help_text="Project start date.")
    end_date = models.DateField(null=True, blank=True, help_text="Project expected end date.")
    status = models.CharField(max_length=50, default="planning", help_text="Current status of the project.")

    def __str__(self):
        return self.title

class Milestone(BaseModel):
    """
    Represents a milestone within a project.
    """
    project = models.ForeignKey(
        Project,
        on_delete=models.CASCADE,
        related_name="milestones",
        help_text="The project to which this milestone belongs."
    )
    title = models.CharField(max_length=255, help_text="Title of the milestone.")
    description = models.TextField(null=True, blank=True, help_text="Milestone description.")
    due_date = models.DateField(null=True, blank=True, help_text="Due date for the milestone.")
    status = models.CharField(max_length=50, default="pending", help_text="Status of the milestone.")

    def __str__(self):
        return f"{self.project.title} - {self.title}"

class Task(BaseModel):
    """
    Represents a task under a milestone.
    """
    milestone = models.ForeignKey(
        Milestone,
        on_delete=models.CASCADE,
        related_name="tasks",
        help_text="Milestone to which this task belongs."
    )
    title = models.CharField(max_length=255, help_text="Task title.")
    description = models.TextField(null=True, blank=True, help_text="Task description.")
    assigned_to = models.ForeignKey(
        "core.CustomUser",
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="tasks",
        help_text="User assigned to this task."
    )
    due_date = models.DateField(null=True, blank=True, help_text="Due date for the task.")
    is_completed = models.BooleanField(default=False, help_text="Indicates if the task is completed.")

    def __str__(self):
        status = "Completed" if self.is_completed else "Pending"
        return f"{self.title} ({status})"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\keenkonnect\projects\serializers.py ---
from rest_framework import serializers
from keenkonnect.projects.models import Project, Milestone, Task

class ProjectSerializer(serializers.ModelSerializer):
    owner = serializers.PrimaryKeyRelatedField(read_only=True)

    class Meta:
        model = Project
        fields = [
            'id',
            'title',
            'description',
            'owner',
            'progress',
            'start_date',
            'end_date',
            'status',
            'created_at',
            'updated_at'
        ]

class MilestoneSerializer(serializers.ModelSerializer):
    project = serializers.PrimaryKeyRelatedField(read_only=True)

    class Meta:
        model = Milestone
        fields = [
            'id',
            'project',
            'title',
            'description',
            'due_date',
            'status',
            'created_at',
            'updated_at'
        ]

class TaskSerializer(serializers.ModelSerializer):
    milestone = serializers.PrimaryKeyRelatedField(read_only=True)
    assigned_to = serializers.PrimaryKeyRelatedField(read_only=True)

    class Meta:
        model = Task
        fields = [
            'id',
            'milestone',
            'title',
            'description',
            'assigned_to',
            'due_date',
            'is_completed',
            'created_at',
            'updated_at'
        ]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\keenkonnect\projects\urls.py ---
# apps/keenkonnect/projects/urls.py
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from keenkonnect.projects.views import ProjectViewSet, MilestoneViewSet, TaskViewSet

router = DefaultRouter()
router.register(r'projects', ProjectViewSet)
router.register(r'milestones', MilestoneViewSet)
router.register(r'tasks', TaskViewSet)

urlpatterns = [
    path('', include(router.urls)),
]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\keenkonnect\projects\views.py ---
# apps/keenkonnect/projects/views.py

from rest_framework import viewsets, permissions, status
from rest_framework.decorators import action
from rest_framework.response import Response

from keenkonnect.projects.models import Project, Milestone, Task
from keenkonnect.projects.serializers import (
    ProjectSerializer,
    MilestoneSerializer,
    TaskSerializer
)

class ProjectViewSet(viewsets.ModelViewSet):
    """
    ViewSet pour gérer les projets collaboratifs.
    """
    queryset = Project.objects.all()
    serializer_class = ProjectSerializer
    permission_classes = [permissions.IsAuthenticated]

    @action(detail=True, methods=['post'], permission_classes=[permissions.IsAuthenticated])
    def change_status(self, request, pk=None):
        """
        Action personnalisée pour modifier le statut d'un projet.
        Par exemple : 'planning', 'in_progress', 'completed', etc.
        """
        project = self.get_object()
        new_status = request.data.get('status')
        if not new_status:
            return Response({'error': 'Le champ "status" est requis.'}, status=status.HTTP_400_BAD_REQUEST)
        project.status = new_status
        project.save()
        return Response(self.get_serializer(project).data)

class MilestoneViewSet(viewsets.ModelViewSet):
    """
    ViewSet pour gérer les jalons (milestones) d'un projet.
    """
    queryset = Milestone.objects.all()
    serializer_class = MilestoneSerializer
    permission_classes = [permissions.IsAuthenticated]

class TaskViewSet(viewsets.ModelViewSet):
    """
    ViewSet pour gérer les tâches d'un jalon de projet.
    """
    queryset = Task.objects.all()
    serializer_class = TaskSerializer
    permission_classes = [permissions.IsAuthenticated]

    @action(detail=True, methods=['post'], permission_classes=[permissions.IsAuthenticated])
    def mark_completed(self, request, pk=None):
        """
        Action personnalisée pour marquer une tâche comme complétée.
        """
        task = self.get_object()
        task.is_completed = True
        task.save()
        return Response(self.get_serializer(task).data)

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\keenkonnect\team_formation\admin.py ---
# apps/keenkonnect/team_formation/admin.py

from django.contrib import admin
from keenkonnect.team_formation.models import TeamFormationRequest, TeamFormationCandidate

@admin.register(TeamFormationRequest)
class TeamFormationRequestAdmin(admin.ModelAdmin):
    list_display = ('project', 'requested_by', 'created_at')
    search_fields = ('project__title', 'requested_by__username')
    ordering = ('-created_at',)
    
    actions = ['trigger_team_formation']

    def trigger_team_formation(self, request, queryset):
        # Intégrer ici l'appel à une tâche asynchrone si besoin
        count = queryset.count()
        self.message_user(request, f"Processus de formation d'équipe déclenché pour {count} demande(s).")
    trigger_team_formation.short_description = "Déclencher la formation d'équipe pour les demandes sélectionnées"

@admin.register(TeamFormationCandidate)
class TeamFormationCandidateAdmin(admin.ModelAdmin):
    list_display = ('formation_request', 'user', 'compatibility_score', 'created_at')
    search_fields = ('user__username',)
    ordering = ('-created_at',)

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\keenkonnect\team_formation\apps.py ---
from django.apps import AppConfig

class KeenkonnectTeamFormationConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'keenkonnect.team_formation'
    verbose_name = "Keenkonnect Team Formation"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\keenkonnect\team_formation\forms.py ---

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\keenkonnect\team_formation\models.py ---
"""
File: apps/keenkonnect/keenTeamFormation/models.py

This module defines models for AI-driven team formation.
It captures team formation requests and candidate evaluations with computed compatibility scores.
"""

from django.db import models
from common.base_models import BaseModel

class TeamFormationRequest(BaseModel):
    """
    Represents a request to form a team for a project.
    """
    project = models.ForeignKey(
        "projects.Project",
        on_delete=models.CASCADE,
        related_name="team_formation_requests",
        help_text="Project for which the team is being formed."
    )
    requested_by = models.ForeignKey(
        "core.CustomUser",
        on_delete=models.SET_NULL,
        null=True,
        related_name="team_formation_requests",
        help_text="User who initiated the team formation request."
    )
    required_roles = models.JSONField(null=True, blank=True, help_text="JSON specifying required roles and skills.")
    additional_info = models.TextField(null=True, blank=True, help_text="Additional information about the request.")

    def __str__(self):
        return f"Team Formation Request for {self.project.title}"

class TeamFormationCandidate(BaseModel):
    """
    Represents a candidate for team formation, with a computed compatibility score.
    """
    formation_request = models.ForeignKey(
        TeamFormationRequest,
        on_delete=models.CASCADE,
        related_name="candidates",
        help_text="Associated team formation request."
    )
    user = models.ForeignKey(
        "core.CustomUser",
        on_delete=models.CASCADE,
        related_name="team_formation_candidates",
        help_text="User being considered for the team."
    )
    skills = models.JSONField(null=True, blank=True, help_text="JSON data representing the user's skills.")
    compatibility_score = models.FloatField(default=0, help_text="Computed compatibility score.")

    def __str__(self):
        return f"Candidate {self.user} - Score: {self.compatibility_score}"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\keenkonnect\team_formation\serializers.py ---
from rest_framework import serializers
from keenkonnect.team_formation.models import TeamFormationRequest, TeamFormationCandidate

class TeamFormationRequestSerializer(serializers.ModelSerializer):
    project = serializers.PrimaryKeyRelatedField(read_only=True)
    requested_by = serializers.PrimaryKeyRelatedField(read_only=True)

    class Meta:
        model = TeamFormationRequest
        fields = [
            'id',
            'project',
            'requested_by',
            'required_roles',
            'additional_info',
            'created_at',
            'updated_at'
        ]

class TeamFormationCandidateSerializer(serializers.ModelSerializer):
    formation_request = serializers.PrimaryKeyRelatedField(read_only=True)
    user = serializers.PrimaryKeyRelatedField(read_only=True)

    class Meta:
        model = TeamFormationCandidate
        fields = [
            'id',
            'formation_request',
            'user',
            'skills',
            'compatibility_score',
            'created_at',
            'updated_at'
        ]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\keenkonnect\team_formation\urls.py ---
# apps/keenkonnect/team_formation/urls.py
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from keenkonnect.team_formation.views import TeamFormationRequestViewSet, TeamFormationCandidateViewSet

router = DefaultRouter()
router.register(r'team_formation_requests', TeamFormationRequestViewSet)
router.register(r'team_formation_candidates', TeamFormationCandidateViewSet)

urlpatterns = [
    path('', include(router.urls)),
]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\keenkonnect\team_formation\views.py ---
# apps/keenkonnect/team_formation/views.py

from rest_framework import viewsets, permissions, status
from rest_framework.decorators import action
from rest_framework.response import Response

from keenkonnect.team_formation.models import TeamFormationRequest, TeamFormationCandidate
from keenkonnect.team_formation.serializers import (
    TeamFormationRequestSerializer,
    TeamFormationCandidateSerializer
)
# Exemple : Importer une tâche asynchrone pour lancer la formation d'équipe basée sur l'IA
# from keenkonnect.team_formation.tasks import trigger_team_formation

class TeamFormationRequestViewSet(viewsets.ModelViewSet):
    """
    ViewSet pour gérer les demandes de formation d'équipe.
    """
    queryset = TeamFormationRequest.objects.all()
    serializer_class = TeamFormationRequestSerializer
    permission_classes = [permissions.IsAuthenticated]

    @action(detail=True, methods=['post'], permission_classes=[permissions.IsAuthenticated])
    def form_team(self, request, pk=None):
        """
        Action personnalisée pour déclencher le processus de formation d'équipe.
        """
        formation_request = self.get_object()
        # Exemple : déclencher la tâche asynchrone pour formation d'équipe
        # trigger_team_formation.delay(formation_request.id)
        return Response({"status": "Processus de formation déclenché", "request_id": formation_request.id})

class TeamFormationCandidateViewSet(viewsets.ModelViewSet):
    """
    ViewSet pour gérer les candidats à la formation d'équipe.
    """
    queryset = TeamFormationCandidate.objects.all()
    serializer_class = TeamFormationCandidateSerializer
    permission_classes = [permissions.IsAuthenticated]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnaxion\urls.py ---
# apps/konnaxion/urls.py

from django.urls import path, include

urlpatterns = [
    path('core/', include('konnaxion.core.urls')),             # URL pour l'app core (utilisateurs, configuration, etc.)
    path('search/', include('konnaxion.search.urls')),           # URL pour l'app search
    path('ai/', include('konnaxion.ai.urls')),                   # URL pour l'app ai
    path('notifications/', include('konnaxion.notifications.urls')),  # URL pour l'app notifications
    path('messaging/', include('konnaxion.messaging.urls')),     # URL pour l'app messaging
    path('ekoh/', include('konnaxion.ekoh.urls')),               # URL pour l'app ekoh (moteur de réputation)
]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnaxion\views.py ---
from django.http import HttpResponse

def debug_test(request):
    return HttpResponse("Debug test is working!")

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnaxion\ai\admin.py ---
# apps/konnaxion/ai/admin.py

from django.contrib import admin
from konnaxion.ai.models import AIResult

@admin.register(AIResult)
class AIResultAdmin(admin.ModelAdmin):
    list_display = ('result_type', 'source_model', 'source_object_id', 'created_at')
    list_filter = ('result_type',)
    search_fields = ('source_model',)
    ordering = ('-created_at',)

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnaxion\ai\apps.py ---
from django.apps import AppConfig

class KonnaxionAiConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'konnaxion.ai'
    verbose_name = "Konnaxion AI"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnaxion\ai\forms.py ---

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnaxion\ai\models.py ---
"""
File: apps/konnaxion/ai/models.py

This module defines models for AI/ML functionalities that enhance content,
provide recommendations, and perform sentiment analysis.
"""

from django.db import models
from common.base_models import BaseModel

class AIResult(BaseModel):
    """
    Model to store AI-generated results, such as content summaries,
    translations, recommendations, and sentiment analysis.
    """
    RESULT_TYPE_CHOICES = [
        ('summary', 'Summary'),
        ('translation', 'Translation'),
        ('recommendation', 'Recommendation'),
        ('sentiment', 'Sentiment Analysis'),
    ]
    result_type = models.CharField(
        max_length=20,
        choices=RESULT_TYPE_CHOICES,
        help_text="Type of AI result."
    )
    result_data = models.JSONField(
        help_text="The AI-generated result data in JSON format."
    )
    source_model = models.CharField(
        max_length=100,
        help_text="Name of the source model (e.g., Lesson, Debate)."
    )
    source_object_id = models.PositiveIntegerField(
        help_text="ID of the source object for which the AI result was generated."
    )

    def __str__(self):
        return f"{self.get_result_type_display()} for {self.source_model} #{self.source_object_id}"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnaxion\ai\serializers.py ---
from rest_framework import serializers
from konnaxion.ai.models import AIResult

class AIResultSerializer(serializers.ModelSerializer):
    class Meta:
        model = AIResult
        fields = [
            'id',
            'result_type',
            'result_data',
            'source_model',
            'source_object_id',
            'created_at',
            'updated_at'
        ]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnaxion\ai\urls.py ---
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from konnaxion.ai.views import AIResultViewSet

router = DefaultRouter()
router.register(r'results', AIResultViewSet, basename='airesult')

urlpatterns = [
    path('', include(router.urls)),
]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnaxion\ai\views.py ---
from rest_framework import viewsets, permissions
from rest_framework.decorators import action
from rest_framework.response import Response

from konnaxion.ai.models import AIResult
from konnaxion.ai.serializers import AIResultSerializer
# Exemple : Importer la tâche d’analyse IA asynchrone
# from konnaxion.ai.tasks import generate_ai_result

class AIResultViewSet(viewsets.ModelViewSet):
    """
    Endpoints pour les résultats générés par l’IA.
    Possède une action personnalisée pour déclencher le traitement IA sur un objet source.
    """
    queryset = AIResult.objects.all()
    serializer_class = AIResultSerializer
    permission_classes = [permissions.IsAuthenticated]

    @action(detail=False, methods=['post'], url_path='generate', permission_classes=[permissions.IsAuthenticated])
    def generate(self, request):
        """
        Déclenche la génération d’un résultat IA pour un objet source.
        Expects 'source_model' et 'source_object_id' dans request.data.
        """
        source_model = request.data.get('source_model')
        source_object_id = request.data.get('source_object_id')
        if not source_model or not source_object_id:
            return Response({"error": "Les champs 'source_model' et 'source_object_id' sont requis."}, status=400)
        # Exemple : Appeler une tâche asynchrone
        # task = generate_ai_result.delay(source_model, source_object_id)
        return Response({
            "message": "Génération IA déclenchée",
            "source_model": source_model,
            "source_object_id": source_object_id
        })

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnaxion\core\admin.py ---
# apps/konnaxion/core/admin.py

from django.contrib import admin
from django.contrib.auth.admin import UserAdmin
from konnaxion.core.models import CustomUser, SystemConfiguration, ConfigurationChangeLog

@admin.register(CustomUser)
class CustomUserAdmin(UserAdmin):
    list_display = ('username', 'email', 'first_name', 'last_name', 'role', 'is_active', 'is_staff')
    list_filter = ('role', 'is_active', 'is_staff')
    search_fields = ('username', 'email', 'first_name', 'last_name')
    ordering = ('username',)
    
    fieldsets = (
        (None, {'fields': ('username', 'password')}),
        ('Informations personnelles', {'fields': ('first_name', 'last_name', 'email', 'role')}),
        ('Permissions', {'fields': ('is_active', 'is_staff', 'is_superuser', 'groups', 'user_permissions')}),
        ('Dates importantes', {'fields': ('last_login', 'date_joined')}),
    )
    
    actions = ['activate_users', 'deactivate_users']

    def activate_users(self, request, queryset):
        updated = queryset.update(is_active=True)
        self.message_user(request, f"{updated} utilisateur(s) activé(s).")
    activate_users.short_description = "Activer les utilisateurs sélectionnés"

    def deactivate_users(self, request, queryset):
        updated = queryset.update(is_active=False)
        self.message_user(request, f"{updated} utilisateur(s) désactivé(s).")
    deactivate_users.short_description = "Désactiver les utilisateurs sélectionnés"


@admin.register(SystemConfiguration)
class SystemConfigurationAdmin(admin.ModelAdmin):
    list_display = ('key', 'value', 'created_at')
    list_filter = ('key',)
    search_fields = ('key', 'value')
    ordering = ('key',)


@admin.register(ConfigurationChangeLog)
class ConfigurationChangeLogAdmin(admin.ModelAdmin):
    list_display = ('configuration', 'old_value', 'new_value', 'changed_by', 'created_at')
    list_filter = ('configuration', 'changed_by')
    search_fields = ('configuration__key',)
    ordering = ('-created_at',)

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnaxion\core\apps.py ---
from django.apps import AppConfig

class KonnaxionCoreConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'konnaxion.core'
    verbose_name = "Konnaxion Core"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnaxion\core\forms.py ---

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnaxion\core\models.py ---
"""
File: apps/konnaxion/core/models.py

This module defines the core models for user management and system configuration.
It includes a custom user model (extending Django’s AbstractUser) and models for
system-wide settings and configuration change logging.
"""

from django.db import models
from django.contrib.auth.models import AbstractUser
from common.base_models import BaseModel

class CustomUser(BaseModel, AbstractUser):
    """
    Custom user model with additional fields for roles, language preferences,
    device details, and offline synchronization metadata.
    """
    language_preference = models.CharField(
        max_length=10,
        default="en",
        help_text="User's preferred language code."
    )
    device_details = models.JSONField(
        null=True, blank=True,
        help_text="JSON field storing device-related information."
    )
    role = models.CharField(
        max_length=50,
        default="user",
        help_text="User role (e.g., user, admin, moderator)."
    )
    offline_sync_token = models.CharField(
        max_length=255,
        null=True, blank=True,
        help_text="Token for offline synchronization."
    )

    def __str__(self):
        return self.username


class SystemConfiguration(BaseModel):
    """
    Model for storing system-wide configuration settings.
    """
    key = models.CharField(
        max_length=100,
        unique=True,
        help_text="Configuration key identifier."
    )
    value = models.TextField(
        help_text="Configuration value stored as text (JSON or plain text)."
    )
    description = models.TextField(
        null=True, blank=True,
        help_text="Optional description of the configuration setting."
    )

    def __str__(self):
        return f"{self.key}: {self.value}"


class ConfigurationChangeLog(BaseModel):
    """
    Model to log configuration changes for auditing purposes.
    """
    configuration = models.ForeignKey(
        SystemConfiguration,
        on_delete=models.CASCADE,
        related_name="change_logs"
    )
    old_value = models.TextField(
        help_text="Previous configuration value."
    )
    new_value = models.TextField(
        help_text="New configuration value."
    )
    changed_by = models.ForeignKey(
        "core.CustomUser",
        on_delete=models.SET_NULL,
        null=True, blank=True,
        help_text="User who made the change."
    )
    change_reason = models.TextField(
        null=True, blank=True,
        help_text="Optional reason for the change."
    )

    def __str__(self):
        return f"Change on {self.configuration.key} by {self.changed_by or 'System'}"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnaxion\core\serializers.py ---
from rest_framework import serializers
from konnaxion.core.models import CustomUser, SystemConfiguration, ConfigurationChangeLog

class CustomUserSerializer(serializers.ModelSerializer):
    class Meta:
        model = CustomUser
        fields = [
            'id',
            'username',
            'email',
            'first_name',
            'last_name',
            'language_preference',
            'device_details',
            'role',
            'offline_sync_token',
            'created_at',
            'updated_at'
        ]

class SystemConfigurationSerializer(serializers.ModelSerializer):
    class Meta:
        model = SystemConfiguration
        fields = [
            'id',
            'key',
            'value',
            'description',
            'created_at',
            'updated_at'
        ]

class ConfigurationChangeLogSerializer(serializers.ModelSerializer):
    configuration = serializers.PrimaryKeyRelatedField(read_only=True)
    changed_by = serializers.PrimaryKeyRelatedField(read_only=True)

    class Meta:
        model = ConfigurationChangeLog
        fields = [
            'id',
            'configuration',
            'old_value',
            'new_value',
            'changed_by',
            'change_reason',
            'created_at',
            'updated_at'
        ]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnaxion\core\urls.py ---
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from konnaxion.core.views import (
    CustomUserViewSet,
    SystemConfigurationViewSet,
    ConfigurationChangeLogViewSet,
)

router = DefaultRouter()
router.register(r'users', CustomUserViewSet, basename='customuser')
router.register(r'configurations', SystemConfigurationViewSet, basename='systemconfiguration')
router.register(r'configuration-changelogs', ConfigurationChangeLogViewSet, basename='configurationchangelog')

urlpatterns = [
    path('', include(router.urls)),
]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnaxion\core\views.py ---
from rest_framework import viewsets, permissions
from rest_framework.decorators import action
from rest_framework.response import Response

from konnaxion.core.models import CustomUser, SystemConfiguration, ConfigurationChangeLog
from konnaxion.core.serializers import (
    CustomUserSerializer,
    SystemConfigurationSerializer,
    ConfigurationChangeLogSerializer
)
# Exemple : Importer une tâche asynchrone pour consigner les changements de configuration
# from konnaxion.core.tasks import log_configuration_change

class CustomUserViewSet(viewsets.ModelViewSet):
    """
    Endpoints pour la gestion des utilisateurs (CustomUser).
    """
    queryset = CustomUser.objects.all()
    serializer_class = CustomUserSerializer
    permission_classes = [permissions.IsAuthenticated]

    @action(detail=True, methods=['post'], permission_classes=[permissions.IsAuthenticated])
    def update_profile(self, request, pk=None):
        """
        Action personnalisée pour mettre à jour le profil utilisateur.
        (Ici, vous pouvez déclencher un événement asynchrone pour la synchronisation offline ou la notification.)
        """
        user = self.get_object()
        serializer = self.get_serializer(user, data=request.data, partial=True)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        # Exemple : Déclencher une tâche asynchrone pour notifier la mise à jour
        # tasks.trigger_user_update_event.delay(user.id)
        return Response(serializer.data)

class SystemConfigurationViewSet(viewsets.ModelViewSet):
    """
    Endpoints pour la gestion de la configuration système.
    Toute modification peut déclencher un enregistrement asynchrone dans l’historique.
    """
    queryset = SystemConfiguration.objects.all()
    serializer_class = SystemConfigurationSerializer
    permission_classes = [permissions.IsAuthenticated]

    def perform_update(self, serializer):
        instance = serializer.save()
        # Exemple : Déclencher une tâche asynchrone pour enregistrer le changement
        # log_configuration_change.delay(instance.id)

class ConfigurationChangeLogViewSet(viewsets.ReadOnlyModelViewSet):
    """
    Endpoint en lecture seule pour consulter l’historique des modifications de configuration.
    """
    queryset = ConfigurationChangeLog.objects.all()
    serializer_class = ConfigurationChangeLogSerializer
    permission_classes = [permissions.IsAuthenticated]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnaxion\ekoh\admin.py ---
# apps/konnaxion/ekoh/admin.py

from django.contrib import admin
from konnaxion.ekoh.models import ExpertiseTag, ReputationProfile, ReputationEvent, WeightedVote

@admin.register(ExpertiseTag)
class ExpertiseTagAdmin(admin.ModelAdmin):
    list_display = ('name', 'created_at')
    search_fields = ('name',)
    ordering = ('name',)

@admin.register(ReputationProfile)
class ReputationProfileAdmin(admin.ModelAdmin):
    list_display = ('user', 'reputation_score', 'ethical_multiplier', 'created_at')
    list_filter = ('user',)
    search_fields = ('user__username', 'user__email')
    ordering = ('-created_at',)

@admin.register(ReputationEvent)
class ReputationEventAdmin(admin.ModelAdmin):
    list_display = ('reputation_profile', 'event_type', 'event_value', 'timestamp')
    list_filter = ('event_type',)
    search_fields = ('reputation_profile__user__username',)
    ordering = ('-timestamp',)

@admin.register(WeightedVote)
class WeightedVoteAdmin(admin.ModelAdmin):
    list_display = ('user', 'target_id', 'vote_value', 'weight', 'timestamp')
    search_fields = ('target_id',)
    ordering = ('-timestamp',)

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnaxion\ekoh\apps.py ---
from django.apps import AppConfig

class KonnaxionEkohConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'konnaxion.ekoh'
    verbose_name = "Ekoh"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnaxion\ekoh\forms.py ---

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnaxion\ekoh\models.py ---
"""
File: apps/konnaxion/ekoh/models.py

Purpose:
Develop the reputation and ethical trust engine models, including detailed reputation
profiles, event logs, weighted voting, and expertise tags.
"""

from django.db import models
from common.base_models import BaseModel

class ExpertiseTag(BaseModel):
    """
    Represents an expertise tag that classifies a user's area of specialization.
    """
    name = models.CharField(max_length=100, unique=True, help_text="Name of the expertise tag")
    description = models.TextField(null=True, blank=True, help_text="Description of the expertise tag")

    def __str__(self):
        return self.name

class ReputationProfile(BaseModel):
    """
    Captures detailed reputation and ethical trust data for a user.
    """
    user = models.OneToOneField(
        "core.CustomUser",
        on_delete=models.CASCADE,
        related_name="reputation_profile",
        help_text="User's reputation profile"
    )
    reputation_score = models.FloatField(default=0, help_text="Overall reputation score")
    ethical_multiplier = models.FloatField(default=1.0, help_text="Multiplier used for ethical adjustments")
    expertise_tags = models.ManyToManyField(
        ExpertiseTag,
        blank=True,
        related_name="profiles",
        help_text="Expertise tags assigned to the user"
    )

    def __str__(self):
        return f"Reputation Profile for {self.user}"

class ReputationEvent(BaseModel):
    """
    Logs events that impact a user's reputation.
    """
    reputation_profile = models.ForeignKey(
        ReputationProfile,
        on_delete=models.CASCADE,
        related_name="events",
        help_text="Associated reputation profile"
    )
    event_type = models.CharField(max_length=50, help_text="Type of event (e.g., vote, contribution)")
    event_value = models.FloatField(help_text="Numerical impact of the event")
    description = models.TextField(null=True, blank=True, help_text="Context or description of the event")
    timestamp = models.DateTimeField(auto_now_add=True, help_text="When the event occurred")

    def __str__(self):
        return f"{self.event_type} event for {self.reputation_profile.user}"

class WeightedVote(BaseModel):
    """
    Records a vote cast by a user with a weight determined by reputation.
    """
    user = models.ForeignKey(
        "core.CustomUser",
        on_delete=models.CASCADE,
        related_name="weighted_votes",
        help_text="User casting the vote"
    )
    target_id = models.PositiveIntegerField(help_text="ID of the target (e.g., a debate argument)")
    vote_value = models.IntegerField(help_text="Vote value (e.g., +1 or -1)")
    weight = models.FloatField(help_text="Vote weight based on reputation")
    timestamp = models.DateTimeField(auto_now_add=True, help_text="Timestamp when the vote was cast")

    def __str__(self):
        return f"Vote by {self.user} on target {self.target_id}: {self.vote_value}"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnaxion\ekoh\serializers.py ---
from rest_framework import serializers
from konnaxion.ekoh.models import ExpertiseTag, ReputationProfile, ReputationEvent, WeightedVote

class ExpertiseTagSerializer(serializers.ModelSerializer):
    class Meta:
        model = ExpertiseTag
        fields = [
            'id',
            'name',
            'description',
            'created_at',
            'updated_at'
        ]

class ReputationProfileSerializer(serializers.ModelSerializer):
    expertise_tags = ExpertiseTagSerializer(many=True, read_only=True)
    user = serializers.PrimaryKeyRelatedField(read_only=True)

    class Meta:
        model = ReputationProfile
        fields = [
            'id',
            'user',
            'reputation_score',
            'ethical_multiplier',
            'expertise_tags',
            'created_at',
            'updated_at'
        ]

class ReputationEventSerializer(serializers.ModelSerializer):
    reputation_profile = serializers.PrimaryKeyRelatedField(read_only=True)

    class Meta:
        model = ReputationEvent
        fields = [
            'id',
            'reputation_profile',
            'event_type',
            'event_value',
            'description',
            'timestamp',
            'created_at',
            'updated_at'
        ]

class WeightedVoteSerializer(serializers.ModelSerializer):
    user = serializers.PrimaryKeyRelatedField(read_only=True)

    class Meta:
        model = WeightedVote
        fields = [
            'id',
            'user',
            'target_id',
            'vote_value',
            'weight',
            'timestamp',
            'created_at',
            'updated_at'
        ]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnaxion\ekoh\urls.py ---
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from konnaxion.ekoh.views import (
    ExpertiseTagViewSet,
    ReputationProfileViewSet,
    ReputationEventViewSet,
    WeightedVoteViewSet,
)

router = DefaultRouter()
router.register(r'expertise-tags', ExpertiseTagViewSet, basename='expertise-tag')
router.register(r'reputation-profiles', ReputationProfileViewSet, basename='reputation-profile')
router.register(r'reputation-events', ReputationEventViewSet, basename='reputation-event')
router.register(r'weighted-votes', WeightedVoteViewSet, basename='weighted-vote')

urlpatterns = [
    path('', include(router.urls)),
]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnaxion\ekoh\views.py ---
from rest_framework import viewsets, permissions
from rest_framework.decorators import action
from rest_framework.response import Response

from konnaxion.ekoh.models import ExpertiseTag, ReputationProfile, ReputationEvent, WeightedVote
from konnaxion.ekoh.serializers import (
    ExpertiseTagSerializer,
    ReputationProfileSerializer,
    ReputationEventSerializer,
    WeightedVoteSerializer
)
# Exemple : Importer une tâche pour recalculer la réputation
# from konnaxion.ekoh.tasks import recalculate_reputation

class ExpertiseTagViewSet(viewsets.ModelViewSet):
    """
    Endpoints pour gérer les tags d'expertise.
    """
    queryset = ExpertiseTag.objects.all()
    serializer_class = ExpertiseTagSerializer
    permission_classes = [permissions.IsAuthenticated]

class ReputationProfileViewSet(viewsets.ModelViewSet):
    """
    Endpoints pour consulter et mettre à jour le profil de réputation des utilisateurs.
    """
    queryset = ReputationProfile.objects.all()
    serializer_class = ReputationProfileSerializer
    permission_classes = [permissions.IsAuthenticated]

class ReputationEventViewSet(viewsets.ReadOnlyModelViewSet):
    """
    Endpoints en lecture seule pour consulter les événements impactant la réputation.
    """
    queryset = ReputationEvent.objects.all()
    serializer_class = ReputationEventSerializer
    permission_classes = [permissions.IsAuthenticated]

class WeightedVoteViewSet(viewsets.ModelViewSet):
    """
    Endpoints pour la gestion des votes pondérés.
    À la création d'un vote, un recalcul asynchrone de la réputation peut être déclenché.
    """
    queryset = WeightedVote.objects.all()
    serializer_class = WeightedVoteSerializer
    permission_classes = [permissions.IsAuthenticated]

    def perform_create(self, serializer):
        vote = serializer.save()
        # Exemple : Déclencher la tâche de recalcul de réputation
        # recalculate_reputation.delay(vote.user.id, vote.target_id, vote.vote_value)

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnaxion\messaging\admin.py ---
# apps/konnaxion/messaging/admin.py

from django.contrib import admin
from konnaxion.messaging.models import Conversation, Message

@admin.register(Conversation)
class ConversationAdmin(admin.ModelAdmin):
    list_display = ('id', 'display_participants', 'created_at')
    search_fields = ('participants__username',)
    ordering = ('id',)

    def display_participants(self, obj):
        return ", ".join([user.username for user in obj.participants.all()])
    display_participants.short_description = "Participants"

@admin.register(Message)
class MessageAdmin(admin.ModelAdmin):
    list_display = ('conversation', 'sender', 'is_read', 'created_at')
    list_filter = ('is_read', 'sender')
    search_fields = ('content',)
    ordering = ('-created_at',)

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnaxion\messaging\apps.py ---
from django.apps import AppConfig

class KonnaxionMessagingConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'konnaxion.messaging'
    verbose_name = "Konnaxion Messaging"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnaxion\messaging\forms.py ---

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnaxion\messaging\models.py ---
"""
File: apps/konnaxion/messaging/models.py

This module defines models for real‑time and persistent messaging, including
conversation threads and individual messages.
"""

from django.db import models
from common.base_models import BaseModel

class Conversation(BaseModel):
    """
    Model representing a conversation or chat thread between users.
    """
    participants = models.ManyToManyField(
        "core.CustomUser",
        related_name='conversations',
        help_text="Users participating in this conversation."
    )
    title = models.CharField(
        max_length=255,
        null=True, blank=True,
        help_text="Optional title for the conversation."
    )

    def __str__(self):
        # Note: accessing all participants in __str__ might be heavy in some contexts.
        participant_names = ", ".join([str(user) for user in self.participants.all()])
        return f"Conversation between: {participant_names}"


class Message(BaseModel):
    """
    Model for individual messages within a conversation.
    """
    conversation = models.ForeignKey(
        Conversation,
        on_delete=models.CASCADE,
        related_name='messages',
        help_text="The conversation this message belongs to."
    )
    sender = models.ForeignKey(
        "core.CustomUser",
        on_delete=models.CASCADE,
        related_name='sent_messages',
        help_text="User who sent the message."
    )
    content = models.TextField(
        help_text="The text content of the message."
    )
    is_read = models.BooleanField(
        default=False,
        help_text="Indicates if the message has been read by the recipient."
    )

    def __str__(self):
        return f"Message from {self.sender} in Conversation #{self.conversation.id}"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnaxion\messaging\serializers.py ---
from rest_framework import serializers
from konnaxion.messaging.models import Conversation, Message

class ConversationSerializer(serializers.ModelSerializer):
    participants = serializers.PrimaryKeyRelatedField(many=True, read_only=True)

    class Meta:
        model = Conversation
        fields = [
            'id',
            'participants',
            'title',
            'created_at',
            'updated_at'
        ]

class MessageSerializer(serializers.ModelSerializer):
    conversation = serializers.PrimaryKeyRelatedField(read_only=True)
    sender = serializers.PrimaryKeyRelatedField(read_only=True)

    class Meta:
        model = Message
        fields = [
            'id',
            'conversation',
            'sender',
            'content',
            'is_read',
            'created_at',
            'updated_at'
        ]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnaxion\messaging\urls.py ---
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from konnaxion.messaging.views import ConversationViewSet, MessageViewSet

router = DefaultRouter()
router.register(r'conversations', ConversationViewSet, basename='conversation')
router.register(r'messages', MessageViewSet, basename='message')

urlpatterns = [
    path('', include(router.urls)),
]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnaxion\messaging\views.py ---
from rest_framework import viewsets, permissions
from rest_framework.decorators import action
from rest_framework.response import Response

from konnaxion.messaging.models import Conversation, Message
from konnaxion.messaging.serializers import ConversationSerializer, MessageSerializer
# Exemple : Importer une tâche pour notifier en temps réel (WebSocket/Celery)
# from konnaxion.messaging.tasks import notify_new_message

class ConversationViewSet(viewsets.ModelViewSet):
    """
    Endpoints pour la gestion des conversations.
    """
    queryset = Conversation.objects.all()
    serializer_class = ConversationSerializer
    permission_classes = [permissions.IsAuthenticated]

class MessageViewSet(viewsets.ModelViewSet):
    """
    Endpoints pour la gestion des messages.
    """
    queryset = Message.objects.all()
    serializer_class = MessageSerializer
    permission_classes = [permissions.IsAuthenticated]

    @action(detail=True, methods=['post'], permission_classes=[permissions.IsAuthenticated])
    def mark_as_read(self, request, pk=None):
        """
        Action personnalisée pour marquer un message comme lu.
        """
        message = self.get_object()
        message.is_read = True
        message.save()
        return Response({"status": "Message marqué comme lu"})

    def perform_create(self, serializer):
        message = serializer.save()
        # Exemple : Déclencher une tâche asynchrone pour notifier les destinataires en temps réel
        # notify_new_message.delay(message.id)

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnaxion\notifications\admin.py ---
# apps/konnaxion/notifications/admin.py

from django.contrib import admin
from konnaxion.notifications.models import Notification

@admin.register(Notification)
class NotificationAdmin(admin.ModelAdmin):
    list_display = ('recipient', 'notification_type', 'is_read', 'created_at')
    list_filter = ('notification_type', 'is_read')
    search_fields = ('message',)
    ordering = ('-created_at',)

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnaxion\notifications\apps.py ---
from django.apps import AppConfig

class KonnaxionNotificationsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'konnaxion.notifications'
    verbose_name = "Konnaxion Notifications"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnaxion\notifications\forms.py ---

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnaxion\notifications\models.py ---
"""
File: apps/konnaxion/notifications/models.py

This module defines the Notification model, which centralizes the creation and
delivery of notifications across the platform.
"""

from django.db import models
from common.base_models import BaseModel

class Notification(BaseModel):
    """
    Model for system notifications.
    """
    NOTIFICATION_TYPE_CHOICES = [
        ('info', 'Info'),
        ('warning', 'Warning'),
        ('error', 'Error'),
    ]
    sender = models.ForeignKey(
        "core.CustomUser",
        on_delete=models.SET_NULL,
        null=True, blank=True,
        related_name='sent_notifications',
        help_text="User who triggered the notification."
    )
    recipient = models.ForeignKey(
        "core.CustomUser",
        on_delete=models.CASCADE,
        related_name='notifications',
        help_text="User who receives the notification."
    )
    message = models.TextField(
        help_text="Notification message content."
    )
    notification_type = models.CharField(
        max_length=20,
        choices=NOTIFICATION_TYPE_CHOICES,
        default='info',
        help_text="Type/category of notification."
    )
    is_read = models.BooleanField(
        default=False,
        help_text="Indicates if the notification has been read."
    )

    def __str__(self):
        return f"Notification for {self.recipient} - {self.get_notification_type_display()}"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnaxion\notifications\serializers.py ---
from rest_framework import serializers
from konnaxion.notifications.models import Notification

class NotificationSerializer(serializers.ModelSerializer):
    sender = serializers.PrimaryKeyRelatedField(read_only=True)
    recipient = serializers.PrimaryKeyRelatedField(read_only=True)

    class Meta:
        model = Notification
        fields = [
            'id',
            'sender',
            'recipient',
            'message',
            'notification_type',
            'is_read',
            'created_at',
            'updated_at'
        ]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnaxion\notifications\urls.py ---
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from konnaxion.notifications.views import NotificationViewSet

router = DefaultRouter()
router.register(r'notifications', NotificationViewSet, basename='notification')

urlpatterns = [
    path('', include(router.urls)),
]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnaxion\notifications\views.py ---
from rest_framework import viewsets, permissions
from rest_framework.decorators import action
from rest_framework.response import Response

from konnaxion.notifications.models import Notification
from konnaxion.notifications.serializers import NotificationSerializer

class NotificationViewSet(viewsets.ModelViewSet):
    """
    Endpoints pour la gestion des notifications.
    """
    queryset = Notification.objects.all()
    serializer_class = NotificationSerializer
    permission_classes = [permissions.IsAuthenticated]

    @action(detail=True, methods=['post'], permission_classes=[permissions.IsAuthenticated])
    def mark_as_read(self, request, pk=None):
        """
        Marquer une notification comme lue.
        """
        notification = self.get_object()
        notification.is_read = True
        notification.save()
        return Response({"status": "Notification marquée comme lue"})

    @action(detail=False, methods=['get'], permission_classes=[permissions.IsAuthenticated])
    def unread(self, request):
        """
        Retourne la liste des notifications non lues pour l'utilisateur connecté.
        """
        qs = self.get_queryset().filter(recipient=request.user, is_read=False)
        serializer = self.get_serializer(qs, many=True)
        return Response(serializer.data)

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnaxion\search\admin.py ---
# apps/konnaxion/search/admin.py

from django.contrib import admin
from konnaxion.search.models import SearchIndex, SearchQueryLog

@admin.register(SearchIndex)
class SearchIndexAdmin(admin.ModelAdmin):
    list_display = ('name', 'last_updated')
    search_fields = ('name',)
    ordering = ('name',)


@admin.register(SearchQueryLog)
class SearchQueryLogAdmin(admin.ModelAdmin):
    list_display = ('user', 'query_text', 'results_count', 'created_at')
    list_filter = ('user',)
    search_fields = ('query_text',)
    ordering = ('-created_at',)

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnaxion\search\apps.py ---
from django.apps import AppConfig

class KonnaxionSearchConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'konnaxion.search'
    verbose_name = "Konnaxion Search"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnaxion\search\forms.py ---

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnaxion\search\models.py ---
"""
File: apps/konnaxion/search/models.py

This module defines models related to search functionality. It includes models
for managing search index configurations and logging user search queries.
"""

from django.db import models
from common.base_models import BaseModel

class SearchIndex(BaseModel):
    """
    Model for storing search index configurations.
    """
    name = models.CharField(
        max_length=255,
        help_text="Name of the search index."
    )
    settings = models.JSONField(
        null=True, blank=True,
        help_text="JSON configuration for the index."
    )
    last_updated = models.DateTimeField(
        auto_now=True,
        help_text="Timestamp when the index was last updated."
    )

    def __str__(self):
        return self.name


class SearchQueryLog(BaseModel):
    """
    Model for logging search queries performed by users.
    """
    user = models.ForeignKey(
        "core.CustomUser",
        on_delete=models.SET_NULL,
        null=True, blank=True,
        help_text="User who made the search query."
    )
    query_text = models.TextField(
        help_text="The search query entered by the user."
    )
    results_count = models.PositiveIntegerField(
        default=0,
        help_text="Number of results returned for the query."
    )

    def __str__(self):
        return f"Query: {self.query_text[:50]}"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnaxion\search\serializers.py ---
from rest_framework import serializers
from konnaxion.search.models import SearchIndex, SearchQueryLog

class SearchIndexSerializer(serializers.ModelSerializer):
    class Meta:
        model = SearchIndex
        fields = [
            'id',
            'name',
            'settings',
            'last_updated',
            'created_at',
            'updated_at'
        ]

class SearchQueryLogSerializer(serializers.ModelSerializer):
    user = serializers.PrimaryKeyRelatedField(read_only=True)

    class Meta:
        model = SearchQueryLog
        fields = [
            'id',
            'user',
            'query_text',
            'results_count',
            'created_at',
            'updated_at'
        ]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnaxion\search\urls.py ---
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from konnaxion.search.views import SearchIndexViewSet, SearchQueryLogViewSet

router = DefaultRouter()
router.register(r'indexes', SearchIndexViewSet, basename='searchindex')
router.register(r'querylogs', SearchQueryLogViewSet, basename='searchquerylog')

urlpatterns = [
    path('', include(router.urls)),
]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnaxion\search\views.py ---
from rest_framework import viewsets, permissions
from konnaxion.search.models import SearchIndex, SearchQueryLog
from konnaxion.search.serializers import SearchIndexSerializer, SearchQueryLogSerializer

class SearchIndexViewSet(viewsets.ModelViewSet):
    """
    Endpoints pour gérer la configuration des index de recherche.
    """
    queryset = SearchIndex.objects.all()
    serializer_class = SearchIndexSerializer
    permission_classes = [permissions.IsAuthenticated]

class SearchQueryLogViewSet(viewsets.ReadOnlyModelViewSet):
    """
    Endpoints en lecture seule pour consulter les journaux des requêtes de recherche.
    """
    queryset = SearchQueryLog.objects.all()
    serializer_class = SearchQueryLogSerializer
    permission_classes = [permissions.IsAuthenticated]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnected\foundation\admin.py ---
# apps/konnected/foundation/admin.py

from django.contrib import admin
from konnected.foundation.models import KnowledgeUnit

@admin.register(KnowledgeUnit)
class KnowledgeUnitAdmin(admin.ModelAdmin):
    list_display = ('title', 'language', 'version', 'created_at')
    list_filter = ('language', 'version')
    search_fields = ('title', 'content')
    ordering = ('title',)
    
    fieldsets = (
        (None, {'fields': ('title', 'content')}),
        ('Détails', {'fields': ('language', 'version')}),
    )

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnected\foundation\apps.py ---
from django.apps import AppConfig

class KonnectedFoundationConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'konnected.foundation'
    verbose_name = "Konnected Foundation"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnected\foundation\forms.py ---

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnected\foundation\models.py ---
"""
File: apps/konnected/foundation/models.py

This module manages the core educational content (“Knowledge Units”).
It includes models for storing rich text, multimedia, and resource attachments,
with support for versioning and audit trails.
"""

from django.db import models
from common.base_models import BaseModel

class KnowledgeUnit(BaseModel):
    """
    Represents a unit of educational content.
    """
    title = models.CharField(max_length=255, help_text="Title of the knowledge unit.")
    content = models.TextField(help_text="Rich text content of the knowledge unit.")
    attachments = models.JSONField(
        null=True,
        blank=True,
        help_text="JSON list of attachment URLs or metadata."
    )
    language = models.CharField(
        max_length=10,
        default="en",
        help_text="Language code for the content."
    )
    version = models.PositiveIntegerField(
        default=1,
        help_text="Version number of the knowledge unit."
    )

    def __str__(self):
        return self.title

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnected\foundation\serializers.py ---
from rest_framework import serializers
from konnected.foundation.models import KnowledgeUnit

class KnowledgeUnitSerializer(serializers.ModelSerializer):
    class Meta:
        model = KnowledgeUnit
        fields = [
            'id',
            'title',
            'content',
            'attachments',
            'language',
            'version',
            'created_at',
            'updated_at'
        ]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnected\foundation\urls.py ---
# apps/konnected/foundation/urls.py
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from konnected.foundation.views import KnowledgeUnitViewSet

router = DefaultRouter()
router.register(r'knowledge_units', KnowledgeUnitViewSet)

urlpatterns = [
    path('', include(router.urls)),
]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnected\foundation\views.py ---
# apps/konnected/foundation/views.py

from rest_framework import viewsets, permissions
from konnected.foundation.models import KnowledgeUnit
from konnected.foundation.serializers import KnowledgeUnitSerializer

class KnowledgeUnitViewSet(viewsets.ModelViewSet):
    """
    ViewSet pour gérer les Knowledge Units (contenu éducatif de base).
    """
    queryset = KnowledgeUnit.objects.all()
    serializer_class = KnowledgeUnitSerializer
    permission_classes = [permissions.IsAuthenticated]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnected\konnectedcommunity\admin.py ---
# apps/konnected/konnectedcommunity/admin.py

from django.contrib import admin
from konnected.konnectedcommunity.models import DiscussionThread, Comment

class CommentInline(admin.TabularInline):
    model = Comment
    extra = 1
    fields = ('author', 'content', 'created_at')
    readonly_fields = ('created_at',)

@admin.register(DiscussionThread)
class DiscussionThreadAdmin(admin.ModelAdmin):
    list_display = ('title', 'author', 'created_at', 'comment_count')
    search_fields = ('title', 'content')
    ordering = ('-created_at',)
    inlines = [CommentInline]

    def comment_count(self, obj):
        return obj.comments.count()
    comment_count.short_description = "Nombre de commentaires"

@admin.register(Comment)
class CommentAdmin(admin.ModelAdmin):
    list_display = ('thread', 'author', 'short_content', 'created_at')
    list_filter = ('thread', 'author')
    search_fields = ('content',)
    ordering = ('-created_at',)

    def short_content(self, obj):
        return (obj.content[:75] + '...') if len(obj.content) > 75 else obj.content
    short_content.short_description = "Contenu"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnected\konnectedcommunity\apps.py ---
from django.apps import AppConfig

class KonnectedCommunityConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'konnected.konnectedcommunity'
    verbose_name = "Konnected Community"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnected\konnectedcommunity\forms.py ---

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnected\konnectedcommunity\models.py ---
"""
File: apps/konnected/konnectedcommunity/models.py

This module provides a forum for educational Q&A and discussions.
It includes models for discussion threads and nested comments.
"""

from django.db import models
from common.base_models import BaseModel

class DiscussionThread(BaseModel):
    """
    Represents a discussion thread for educational topics.
    """
    title = models.CharField(max_length=255, help_text="Title of the discussion thread.")
    content = models.TextField(help_text="Initial content or description of the thread.")
    author = models.ForeignKey(
        "core.CustomUser",
        on_delete=models.CASCADE,
        related_name="discussion_threads",
        help_text="User who started the discussion."
    )

    def __str__(self):
        return self.title

class Comment(BaseModel):
    """
    Represents a comment on a discussion thread, supporting nested replies.
    """
    thread = models.ForeignKey(
        DiscussionThread,
        on_delete=models.CASCADE,
        related_name="comments",
        help_text="The discussion thread to which this comment belongs."
    )
    parent = models.ForeignKey(
        'self',
        on_delete=models.CASCADE,
        null=True,
        blank=True,
        related_name="replies",
        help_text="Parent comment if this is a reply; null if top-level."
    )
    author = models.ForeignKey(
        "core.CustomUser",
        on_delete=models.CASCADE,
        related_name="comments",
        help_text="User who posted the comment."
    )
    content = models.TextField(help_text="Content of the comment.")
    vote_count = models.IntegerField(
        default=0,
        help_text="Net vote count for the comment."
    )

    def __str__(self):
        return f"Comment by {self.author} on {self.thread.title}"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnected\konnectedcommunity\serializers.py ---
from rest_framework import serializers
from konnected.konnectedcommunity.models import DiscussionThread, Comment

class DiscussionThreadSerializer(serializers.ModelSerializer):
    class Meta:
        model = DiscussionThread
        fields = [
            'id',
            'title',
            'content',
            'author',
            'created_at',
            'updated_at'
        ]

class CommentSerializer(serializers.ModelSerializer):
    replies = serializers.SerializerMethodField()

    class Meta:
        model = Comment
        fields = [
            'id',
            'thread',
            'parent',
            'author',
            'content',
            'vote_count',
            'created_at',
            'updated_at',
            'replies'
        ]

    def get_replies(self, obj):
        qs = obj.replies.all()
        return CommentSerializer(qs, many=True).data

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnected\konnectedcommunity\urls.py ---
from django.urls import path
from .views import (
    DiscussionThreadListView,
    DiscussionThreadDetailView,
    DiscussionThreadCreateView,
    CommentCreateView,
)

app_name = "community"

urlpatterns = [
    path("", DiscussionThreadListView.as_view(), name="thread_list"),
    path("thread/<int:pk>/", DiscussionThreadDetailView.as_view(), name="thread_detail"),
    path("thread/create/", DiscussionThreadCreateView.as_view(), name="thread_create"),
    # For posting a comment on a specific thread
    path("thread/<int:thread_pk>/comment/create/", CommentCreateView.as_view(), name="comment_create"),
]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnected\konnectedcommunity\views.py ---
from django.urls import reverse_lazy, reverse
from django.views.generic import ListView, DetailView, CreateView
from django import forms
from .models import DiscussionThread, Comment

# A simple ModelForm for creating a Comment.
class CommentForm(forms.ModelForm):
    class Meta:
        model = Comment
        # We only ask for content (parent can be None for top‐level comments)
        fields = ['content', 'parent']
        widgets = {
            # Optionally hide the parent field in the form if you want to
            # restrict it to replying in the detail view
            'parent': forms.HiddenInput(),
        }

class DiscussionThreadListView(ListView):
    """List all discussion threads."""
    model = DiscussionThread
    template_name = "konnected/community/thread_list.html"  # create this template
    context_object_name = "threads"
    paginate_by = 10  # adjust as needed

class DiscussionThreadDetailView(DetailView):
    """Show a single discussion thread and its comments."""
    model = DiscussionThread
    template_name = "konnected/community/thread_detail.html"  # create this template
    context_object_name = "thread"

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        # Get top-level comments (those with no parent)
        context["comments"] = self.object.comments.filter(parent__isnull=True)
        # Provide an empty comment form for adding a comment to this thread.
        context["comment_form"] = CommentForm(initial={"parent": None})
        return context

class DiscussionThreadCreateView(CreateView):
    """Allow a user to create a new discussion thread."""
    model = DiscussionThread
    template_name = "konnected/community/thread_form.html"  # create this template
    fields = ["title", "content"]
    success_url = reverse_lazy("community:thread_list")

    def form_valid(self, form):
        # Set the current user as the author
        form.instance.author = self.request.user
        return super().form_valid(form)

class CommentCreateView(CreateView):
    """Allow a user to add a comment to a thread."""
    model = Comment
    form_class = CommentForm
    template_name = "konnected/community/comment_form.html"  # create this template

    def form_valid(self, form):
        # Set the current user as the author and assign the thread.
        form.instance.author = self.request.user
        # We assume the URL includes a thread_pk parameter.
        thread_pk = self.kwargs.get("thread_pk")
        form.instance.thread = DiscussionThread.objects.get(pk=thread_pk)
        return super().form_valid(form)

    def get_success_url(self):
        # Redirect back to the thread detail page.
        return reverse("community:thread_detail", kwargs={"pk": self.kwargs.get("thread_pk")})

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnected\learning\admin.py ---
# apps/konnected/learning/admin.py

from django.contrib import admin
from konnected.learning.models import Lesson, Quiz, Question, Answer

@admin.register(Lesson)
class LessonAdmin(admin.ModelAdmin):
    list_display = ('title', 'knowledge_unit', 'created_at')
    search_fields = ('title', 'content')
    ordering = ('title',)

@admin.register(Quiz)
class QuizAdmin(admin.ModelAdmin):
    list_display = ('title', 'lesson', 'time_limit', 'created_at')
    list_filter = ('lesson',)
    search_fields = ('title',)
    ordering = ('title',)

class AnswerInline(admin.TabularInline):
    model = Answer
    extra = 1
    fields = ('text', 'is_correct')

@admin.register(Question)
class QuestionAdmin(admin.ModelAdmin):
    list_display = ('short_text', 'quiz', 'question_type', 'created_at')
    list_filter = ('question_type', 'quiz')
    search_fields = ('text',)
    ordering = ('quiz',)
    inlines = [AnswerInline]

    def short_text(self, obj):
        return (obj.text[:75] + '...') if len(obj.text) > 75 else obj.text
    short_text.short_description = "Question"

@admin.register(Answer)
class AnswerAdmin(admin.ModelAdmin):
    list_display = ('question', 'text', 'is_correct', 'created_at')
    list_filter = ('is_correct', 'question')
    search_fields = ('text',)
    ordering = ('question',)

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnected\learning\apps.py ---
from django.apps import AppConfig

class KonnectedLearningConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'konnected.learning'
    verbose_name = "Konnected Learning"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnected\learning\forms.py ---

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnected\learning\models.py ---
"""
File: apps/konnected/konnected_learning/models.py

This module defines models for interactive lessons, quizzes, and assessments.
It includes models for lessons, quizzes, questions, and answers.
"""

from django.db import models
from common.base_models import BaseModel

class Lesson(BaseModel):
    """
    Represents an interactive lesson.
    """
    title = models.CharField(max_length=255, help_text="Title of the lesson.")
    content = models.TextField(help_text="Lesson content, which may include rich text, images, and video links.")
    # Optionally associate a lesson with a knowledge unit.
    knowledge_unit = models.ForeignKey(
        "foundation.KnowledgeUnit",
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="lessons",
        help_text="Associated knowledge unit, if any."
    )

    def __str__(self):
        return self.title

class Quiz(BaseModel):
    """
    Represents a quiz associated with a lesson.
    """
    lesson = models.ForeignKey(
        Lesson,
        on_delete=models.CASCADE,
        related_name="quizzes",
        help_text="Lesson associated with this quiz."
    )
    title = models.CharField(max_length=255, help_text="Title of the quiz.")
    instructions = models.TextField(help_text="Quiz instructions or guidelines.")
    time_limit = models.PositiveIntegerField(
        null=True,
        blank=True,
        help_text="Time limit in minutes, if applicable."
    )

    def __str__(self):
        return f"{self.title} (Quiz for {self.lesson.title})"

class Question(BaseModel):
    """
    Represents a question in a quiz.
    """
    QUESTION_TYPE_CHOICES = [
        ('text', 'Text'),
        ('multiple_choice', 'Multiple Choice'),
    ]
    quiz = models.ForeignKey(
        Quiz,
        on_delete=models.CASCADE,
        related_name="questions",
        help_text="Quiz to which this question belongs."
    )
    text = models.TextField(help_text="The question text.")
    question_type = models.CharField(
        max_length=20,
        choices=QUESTION_TYPE_CHOICES,
        default='text',
        help_text="Type of question."
    )
    correct_answer = models.TextField(
        null=True,
        blank=True,
        help_text="Correct answer for the question (if applicable)."
    )

    def __str__(self):
        return f"Question: {self.text[:50]}..."

class Answer(BaseModel):
    """
    Represents an answer option for a multiple choice question.
    """
    question = models.ForeignKey(
        Question,
        on_delete=models.CASCADE,
        related_name="answers",
        help_text="The question this answer belongs to."
    )
    text = models.TextField(help_text="Answer option text.")
    is_correct = models.BooleanField(
        default=False,
        help_text="Indicates if this is the correct answer."
    )

    def __str__(self):
        return f"Answer: {self.text[:50]}{' (Correct)' if self.is_correct else ''}"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnected\learning\serializers.py ---
from rest_framework import serializers
from konnected.learning.models import Lesson, Quiz, Question, Answer

class LessonSerializer(serializers.ModelSerializer):
    class Meta:
        model = Lesson
        fields = [
            'id',
            'title',
            'content',
            'knowledge_unit',
            'created_at',
            'updated_at'
        ]

class QuizSerializer(serializers.ModelSerializer):
    class Meta:
        model = Quiz
        fields = [
            'id',
            'lesson',
            'title',
            'instructions',
            'time_limit',
            'created_at',
            'updated_at'
        ]

class QuestionSerializer(serializers.ModelSerializer):
    class Meta:
        model = Question
        fields = [
            'id',
            'quiz',
            'text',
            'question_type',
            'correct_answer',
            'created_at',
            'updated_at'
        ]

class AnswerSerializer(serializers.ModelSerializer):
    class Meta:
        model = Answer
        fields = [
            'id',
            'question',
            'text',
            'is_correct',
            'created_at',
            'updated_at'
        ]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnected\learning\urls.py ---
# apps/konnected/learning/urls.py
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from konnected.learning.views import LessonViewSet, QuizViewSet, QuestionViewSet, AnswerViewSet

router = DefaultRouter()
router.register(r'lessons', LessonViewSet)
router.register(r'quizzes', QuizViewSet)
router.register(r'questions', QuestionViewSet)
router.register(r'answers', AnswerViewSet)

urlpatterns = [
    path('', include(router.urls)),
]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnected\learning\views.py ---

# apps/konnected/learning/views.py

from rest_framework import viewsets, permissions
from konnected.learning.models import Lesson, Quiz, Question, Answer
from konnected.learning.serializers import (
    LessonSerializer,
    QuizSerializer,
    QuestionSerializer,
    AnswerSerializer
)

class LessonViewSet(viewsets.ModelViewSet):
    """
    ViewSet pour gérer les leçons interactives.
    """
    queryset = Lesson.objects.all()
    serializer_class = LessonSerializer
    permission_classes = [permissions.IsAuthenticated]

class QuizViewSet(viewsets.ModelViewSet):
    """
    ViewSet pour gérer les quiz associés aux leçons.
    """
    queryset = Quiz.objects.all()
    serializer_class = QuizSerializer
    permission_classes = [permissions.IsAuthenticated]

class QuestionViewSet(viewsets.ModelViewSet):
    """
    ViewSet pour gérer les questions des quiz.
    """
    queryset = Question.objects.all()
    serializer_class = QuestionSerializer
    permission_classes = [permissions.IsAuthenticated]

class AnswerViewSet(viewsets.ModelViewSet):
    """
    ViewSet pour gérer les réponses aux questions.
    """
    queryset = Answer.objects.all()
    serializer_class = AnswerSerializer
    permission_classes = [permissions.IsAuthenticated]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnected\offline\admin.py ---
# apps/konnected/offline/admin.py

from django.contrib import admin
from django.contrib import messages
from konnected.offline.models import OfflineContentPackage

@admin.register(OfflineContentPackage)
class OfflineContentPackageAdmin(admin.ModelAdmin):
    list_display = ('title', 'last_synced', 'created_at')
    search_fields = ('title', 'description')
    ordering = ('-created_at',)
    
    actions = ['trigger_sync']

    def trigger_sync(self, request, queryset):
        # Ici, vous pouvez intégrer l'appel à une tâche asynchrone par exemple via Celery.
        # Pour l'instant, nous simulons simplement l'action avec un message.
        count = queryset.count()
        # Exemple d'appel : sync_offline_content.delay(package.id) pour chaque package
        self.message_user(request, f"Sync déclenché pour {count} package(s).", messages.SUCCESS)
    trigger_sync.short_description = "Déclencher la synchronisation des packages offline"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnected\offline\apps.py ---
from django.apps import AppConfig

class KonnectedOfflineConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'konnected.offline'
    verbose_name = "Konnected Offline"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnected\offline\forms.py ---

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnected\offline\models.py ---
"""
File: apps/konnected/offline/models.py

This module ensures that educational content is available offline.
It includes models for packaging content for offline consumption and tracking synchronization.
"""

from django.db import models
from common.base_models import BaseModel

class OfflineContentPackage(BaseModel):
    """
    Represents a packaged set of educational content for offline use.
    """
    title = models.CharField(max_length=255, help_text="Title of the offline content package.")
    description = models.TextField(
        null=True,
        blank=True,
        help_text="Description of the offline package."
    )
    content_data = models.JSONField(help_text="JSON data representing the packaged content for offline use.")
    last_synced = models.DateTimeField(
        null=True,
        blank=True,
        help_text="Timestamp of the last successful sync."
    )
    conflict_resolution_notes = models.TextField(
        null=True,
        blank=True,
        help_text="Notes on any conflicts during sync."
    )

    def __str__(self):
        return self.title

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnected\offline\serializers.py ---
from rest_framework import serializers
from konnected.offline.models import OfflineContentPackage

class OfflineContentPackageSerializer(serializers.ModelSerializer):
    class Meta:
        model = OfflineContentPackage
        fields = [
            'id',
            'title',
            'description',
            'content_data',
            'last_synced',
            'conflict_resolution_notes',
            'created_at',
            'updated_at'
        ]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnected\offline\urls.py ---
# apps/konnected/offline/urls.py
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from konnected.offline.views import OfflineContentPackageViewSet

router = DefaultRouter()
router.register(r'offline_packages', OfflineContentPackageViewSet)

urlpatterns = [
    path('', include(router.urls)),
]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnected\offline\views.py ---
# apps/konnected/offline/views.py

from rest_framework import viewsets, permissions
from rest_framework.decorators import action
from rest_framework.response import Response
from konnected.offline.models import OfflineContentPackage
from konnected.offline.serializers import OfflineContentPackageSerializer
# Exemple : depuis un module de tâches asynchrones pour lancer la synchronisation
# from konnected.offline.tasks import sync_offline_content

class OfflineContentPackageViewSet(viewsets.ModelViewSet):
    """
    ViewSet pour gérer les packages de contenu pour l'utilisation offline.
    """
    queryset = OfflineContentPackage.objects.all()
    serializer_class = OfflineContentPackageSerializer
    permission_classes = [permissions.IsAuthenticated]

    @action(detail=True, methods=['post'], permission_classes=[permissions.IsAuthenticated])
    def sync(self, request, pk=None):
        """
        Action personnalisée pour déclencher la synchronisation du package offline.
        """
        package = self.get_object()
        # Exemple : déclencher la tâche asynchrone de synchronisation
        # sync_offline_content.delay(package.id)
        return Response({"status": "Sync déclenché", "package_id": package.id})

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnected\paths\admin.py ---
# apps/konnected/paths/admin.py

from django.contrib import admin
from konnected.paths.models import LearningPath, PathStep

class PathStepInline(admin.TabularInline):
    model = PathStep
    extra = 1
    fields = ('knowledge_unit', 'order')

@admin.register(LearningPath)
class LearningPathAdmin(admin.ModelAdmin):
    list_display = ('title', 'created_by', 'created_at')
    search_fields = ('title', 'description')
    ordering = ('title',)
    inlines = [PathStepInline]

@admin.register(PathStep)
class PathStepAdmin(admin.ModelAdmin):
    list_display = ('learning_path', 'knowledge_unit', 'order')
    list_filter = ('learning_path',)
    ordering = ('learning_path', 'order')

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnected\paths\apps.py ---
from django.apps import AppConfig

class KonnectedPathsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'konnected.paths'
    verbose_name = "Konnected Paths"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnected\paths\forms.py ---

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnected\paths\models.py ---
"""
File: apps/konnected/paths/models.py

This module enables the creation of adaptive learning paths.
It includes models for assembling knowledge units into personalized curricula.
"""

from django.db import models
from common.base_models import BaseModel

class LearningPath(BaseModel):
    """
    Represents a personalized learning path (curriculum).
    """
    title = models.CharField(max_length=255, help_text="Title of the learning path.")
    description = models.TextField(
        null=True,
        blank=True,
        help_text="Description of the learning path."
    )
    created_by = models.ForeignKey(
        "core.CustomUser",
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        help_text="User who created the learning path."
    )

    def __str__(self):
        return self.title

class PathStep(BaseModel):
    """
    Represents an individual step within a learning path, linking a knowledge unit.
    """
    learning_path = models.ForeignKey(
        LearningPath,
        on_delete=models.CASCADE,
        related_name="steps",
        help_text="The learning path this step belongs to."
    )
    knowledge_unit = models.ForeignKey(
        "foundation.KnowledgeUnit",
        on_delete=models.CASCADE,
        related_name="path_steps",
        help_text="The knowledge unit associated with this step."
    )
    order = models.PositiveIntegerField(help_text="The order/sequence of this step in the learning path.")

    class Meta:
        ordering = ['order']

    def __str__(self):
        return f"{self.learning_path.title} - Step {self.order}: {self.knowledge_unit.title}"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnected\paths\serializers.py ---
from rest_framework import serializers
from konnected.paths.models import LearningPath, PathStep

class LearningPathSerializer(serializers.ModelSerializer):
    class Meta:
        model = LearningPath
        fields = [
            'id',
            'title',
            'description',
            'created_by',
            'created_at',
            'updated_at'
        ]

class PathStepSerializer(serializers.ModelSerializer):
    learning_path = serializers.PrimaryKeyRelatedField(read_only=True)
    knowledge_unit = serializers.PrimaryKeyRelatedField(read_only=True)

    class Meta:
        model = PathStep
        fields = [
            'id',
            'learning_path',
            'knowledge_unit',
            'order',
            'created_at',
            'updated_at'
        ]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnected\paths\urls.py ---
# apps/konnected/paths/urls.py
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from konnected.paths.views import LearningPathViewSet, PathStepViewSet

router = DefaultRouter()
router.register(r'learning_paths', LearningPathViewSet)
router.register(r'path_steps', PathStepViewSet)

urlpatterns = [
    path('', include(router.urls)),
]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnected\paths\views.py ---
# apps/konnected/paths/views.py

from rest_framework import viewsets, permissions
from konnected.paths.models import LearningPath, PathStep
from konnected.paths.serializers import LearningPathSerializer, PathStepSerializer

class LearningPathViewSet(viewsets.ModelViewSet):
    """
    ViewSet pour gérer la création et la modification des parcours d'apprentissage.
    """
    queryset = LearningPath.objects.all()
    serializer_class = LearningPathSerializer
    permission_classes = [permissions.IsAuthenticated]

class PathStepViewSet(viewsets.ModelViewSet):
    """
    ViewSet pour gérer les étapes individuelles d'un parcours d'apprentissage.
    """
    queryset = PathStep.objects.all()
    serializer_class = PathStepSerializer
    permission_classes = [permissions.IsAuthenticated]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnected\team\admin.py ---
# apps/konnected/team/admin.py

from django.contrib import admin
from konnected.team.models import Team, TeamInvitation

class TeamInvitationInline(admin.TabularInline):
    model = TeamInvitation
    extra = 0
    fields = ('invited_user', 'status', 'created_at')

@admin.register(Team)
class TeamAdmin(admin.ModelAdmin):
    list_display = ('name', 'member_count', 'created_at')
    search_fields = ('name', 'description')
    ordering = ('name',)
    inlines = [TeamInvitationInline]

    def member_count(self, obj):
        return obj.members.count()
    member_count.short_description = "Nombre de membres"

@admin.register(TeamInvitation)
class TeamInvitationAdmin(admin.ModelAdmin):
    list_display = ('team', 'invited_user', 'status', 'created_at')
    list_filter = ('status',)
    search_fields = ('team__name', 'invited_user__username')
    ordering = ('-created_at',)

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnected\team\apps.py ---
from django.apps import AppConfig

class KonnectedTeamConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'konnected.team'
    verbose_name = "Konnected Team"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnected\team\forms.py ---

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnected\team\models.py ---
"""
File: apps/konnected/team/models.py

This module facilitates team creation and management for educational projects.
It includes models for teams and team invitations.
"""

from django.db import models
from common.base_models import BaseModel

class Team(BaseModel):
    """
    Represents an educational team.
    """
    name = models.CharField(max_length=255, help_text="Name of the team.")
    description = models.TextField(
        null=True,
        blank=True,
        help_text="Description of the team."
    )
    members = models.ManyToManyField(
        "core.CustomUser",
        related_name="teams",
        help_text="Users who are members of this team."
    )

    def __str__(self):
        return self.name

class TeamInvitation(BaseModel):
    """
    Represents an invitation for a user to join a team.
    """
    INVITATION_STATUS_CHOICES = [
        ('pending', 'Pending'),
        ('accepted', 'Accepted'),
        ('rejected', 'Rejected'),
    ]
    team = models.ForeignKey(
        Team,
        on_delete=models.CASCADE,
        related_name="invitations",
        help_text="Team for which the invitation is sent."
    )
    invited_user = models.ForeignKey(
        "core.CustomUser",
        on_delete=models.CASCADE,
        related_name="team_invitations",
        help_text="User who is invited."
    )
    status = models.CharField(
        max_length=20,
        choices=INVITATION_STATUS_CHOICES,
        default="pending",
        help_text="Status of the invitation."
    )
    message = models.TextField(
        null=True,
        blank=True,
        help_text="Optional message accompanying the invitation."
    )

    def __str__(self):
        return f"Invitation for {self.invited_user} to join {self.team.name} [{self.status}]"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnected\team\serializers.py ---
from rest_framework import serializers
from konnected.team.models import Team, TeamInvitation

class TeamSerializer(serializers.ModelSerializer):
    members = serializers.PrimaryKeyRelatedField(many=True, read_only=True)

    class Meta:
        model = Team
        fields = [
            'id',
            'name',
            'description',
            'members',
            'created_at',
            'updated_at'
        ]

class TeamInvitationSerializer(serializers.ModelSerializer):
    team = serializers.PrimaryKeyRelatedField(read_only=True)
    invited_user = serializers.PrimaryKeyRelatedField(read_only=True)

    class Meta:
        model = TeamInvitation
        fields = [
            'id',
            'team',
            'invited_user',
            'status',
            'message',
            'created_at',
            'updated_at'
        ]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnected\team\urls.py ---
# apps/konnected/team/urls.py
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from konnected.team.views import TeamViewSet, TeamInvitationViewSet

router = DefaultRouter()
router.register(r'teams', TeamViewSet)
router.register(r'invitations', TeamInvitationViewSet)

urlpatterns = [
    path('', include(router.urls)),
]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\konnected\team\views.py ---
# apps/konnected/team/views.py

from rest_framework import viewsets, permissions
from konnected.team.models import Team, TeamInvitation
from konnected.team.serializers import TeamSerializer, TeamInvitationSerializer

class TeamViewSet(viewsets.ModelViewSet):
    """
    ViewSet pour gérer la création et la gestion des équipes éducatives.
    """
    queryset = Team.objects.all()
    serializer_class = TeamSerializer
    permission_classes = [permissions.IsAuthenticated]

class TeamInvitationViewSet(viewsets.ModelViewSet):
    """
    ViewSet pour gérer les invitations à rejoindre une équipe.
    """
    queryset = TeamInvitation.objects.all()
    serializer_class = TeamInvitationSerializer
    permission_classes = [permissions.IsAuthenticated]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\kreative\urls.py ---
# apps/kreative/artworks/urls.py
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from kreative.artworks.views import ExhibitionViewSet, ArtworkViewSet

router = DefaultRouter()
router.register(r'exhibitions', ExhibitionViewSet)
router.register(r'artworks', ArtworkViewSet)

urlpatterns = [
    path('', include(router.urls)),
]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\kreative\-community\apps.py ---
from django.apps import AppConfig

class KreativeCommunityConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'kreative.kreativecommunity'
    verbose_name = "Kreative Community"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\kreative\artworks\admin.py ---
# apps/kreative/artworks/admin.py

from django.contrib import admin
from kreative.artworks.models import Exhibition, Artwork
from django.utils.html import mark_safe

@admin.register(Exhibition)
class ExhibitionAdmin(admin.ModelAdmin):
    list_display = ('name', 'start_date', 'end_date', 'location', 'created_at')
    list_filter = ('start_date', 'end_date')
    search_fields = ('name', 'description', 'location')
    ordering = ('-start_date',)
    
    fieldsets = (
        (None, {
            'fields': ('name', 'description')
        }),
        ('Détails de l\'exposition', {
            'fields': ('start_date', 'end_date', 'location')
        }),
    )

@admin.register(Artwork)
class ArtworkAdmin(admin.ModelAdmin):
    list_display = ('title', 'exhibition', 'created_at', 'image_tag')
    list_filter = ('exhibition',)
    search_fields = ('title', 'description')
    ordering = ('title',)
    
    fieldsets = (
        (None, {
            'fields': ('title', 'description', 'exhibition')
        }),
        ('Image', {
            'fields': ('image',),
        }),
    )
    
    def image_tag(self, obj):
        if obj.image:
            return mark_safe(f'<img src="{obj.image.url}" width="50" height="50" />')
        return ""
    image_tag.short_description = "Image"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\kreative\artworks\apps.py ---
from django.apps import AppConfig

class KreativeArtworksConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'kreative.artworks'
    verbose_name = "Kreative Artworks"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\kreative\artworks\forms.py ---

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\kreative\artworks\models.py ---
"""
File: apps\kreative\artworks\models.py

Purpose:
Build models for the artwork catalog, including fields for media uploads, metadata,
and exhibition details.
"""

from django.db import models
from common.base_models import BaseModel

class Exhibition(BaseModel):
    """
    Represents an exhibition event for displaying artworks.
    """
    name = models.CharField(max_length=255, help_text="Name of the exhibition")
    description = models.TextField(null=True, blank=True, help_text="Description of the exhibition")
    start_date = models.DateField(null=True, blank=True, help_text="Exhibition start date")
    end_date = models.DateField(null=True, blank=True, help_text="Exhibition end date")
    location = models.CharField(max_length=255, null=True, blank=True, help_text="Location of the exhibition")

    def __str__(self):
        return self.name

class Artwork(BaseModel):
    """
    Represents an individual artwork in the catalog.
    """
    title = models.CharField(max_length=255, help_text="Title of the artwork")
    description = models.TextField(help_text="Description of the artwork")
    image = models.ImageField(upload_to="artworks/", help_text="Image of the artwork")
    metadata = models.JSONField(null=True, blank=True, help_text="Additional metadata (e.g., dimensions, medium)")
    exhibition = models.ForeignKey(
        Exhibition,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="artworks",
        help_text="Exhibition where the artwork is displayed"
    )

    def __str__(self):
        return self.title

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\kreative\artworks\serializers.py ---
from rest_framework import serializers
from kreative.artworks.models import Exhibition, Artwork

class ExhibitionSerializer(serializers.ModelSerializer):
    class Meta:
        model = Exhibition
        fields = [
            'id',
            'name',
            'description',
            'start_date',
            'end_date',
            'location',
            'created_at',
            'updated_at'
        ]

class ArtworkSerializer(serializers.ModelSerializer):
    exhibition = serializers.PrimaryKeyRelatedField(read_only=True)

    class Meta:
        model = Artwork
        fields = [
            'id',
            'title',
            'description',
            'image',
            'metadata',
            'exhibition',
            'created_at',
            'updated_at'
        ]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\kreative\artworks\urls.py ---
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from kreative.artworks.views import ExhibitionViewSet, ArtworkViewSet

router = DefaultRouter()
router.register(r'exhibitions', ExhibitionViewSet, basename='exhibition')
router.register(r'artworks', ArtworkViewSet, basename='artwork')

urlpatterns = [
    path('', include(router.urls)),
]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\kreative\artworks\views.py ---
# apps/kreative/artworks/views.py

from rest_framework import viewsets, permissions
from rest_framework.decorators import action
from rest_framework.response import Response

from kreative.artworks.models import Exhibition, Artwork
from kreative.artworks.serializers import ExhibitionSerializer, ArtworkSerializer

class ExhibitionViewSet(viewsets.ModelViewSet):
    """
    ViewSet pour gérer les expositions (création, modification, suppression et consultation).
    """
    queryset = Exhibition.objects.all()
    serializer_class = ExhibitionSerializer
    permission_classes = [permissions.IsAuthenticated]

    @action(detail=True, methods=['post'], permission_classes=[permissions.IsAuthenticated])
    def activate(self, request, pk=None):
        """
        Action personnalisée pour activer/désactiver une exposition.
        Attendu : un booléen 'active' dans request.data.
        """
        exhibition = self.get_object()
        active = request.data.get('active')
        if active is None:
            return Response({"error": "Le champ 'active' est requis."}, status=400)
        exhibition.active = active
        exhibition.save()
        return Response(self.get_serializer(exhibition).data)

class ArtworkViewSet(viewsets.ModelViewSet):
    """
    ViewSet pour gérer le catalogue des œuvres.
    """
    queryset = Artwork.objects.all()
    serializer_class = ArtworkSerializer
    permission_classes = [permissions.IsAuthenticated]

    @action(detail=False, methods=['get'], permission_classes=[permissions.IsAuthenticated])
    def by_exhibition(self, request):
        """
        Retourne la liste des œuvres filtrées par l'exposition.
        Expects : un paramètre 'exhibition_id' dans les query params.
        """
        exhibition_id = request.query_params.get('exhibition_id')
        if exhibition_id:
            queryset = self.get_queryset().filter(exhibition_id=exhibition_id)
        else:
            queryset = self.get_queryset()
        serializer = self.get_serializer(queryset, many=True)
        return Response(serializer.data)

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\kreative\immersive\admin.py ---
# apps/kreative/immersive/admin.py

from django.contrib import admin
from kreative.immersive.models import ImmersiveExperience

@admin.register(ImmersiveExperience)
class ImmersiveExperienceAdmin(admin.ModelAdmin):
    list_display = ('title', 'media_url', 'created_at')
    search_fields = ('title', 'description')
    ordering = ('-created_at',)
    
    fieldsets = (
        (None, {'fields': ('title', 'description')}),
        ('Contenu Immersif', {'fields': ('media_url',)}),
    )

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\kreative\immersive\apps.py ---
from django.apps import AppConfig

class KreativeImmersiveConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'kreative.immersive'
    verbose_name = "Kreative Immersive"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\kreative\immersive\forms.py ---

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\kreative\immersive\models.py ---
"""
File: apps/kreative/kreative_immersive/models.py

Purpose:
(Optional/Future) Define minimal placeholder models to support AR/VR and immersive cultural experiences.
"""

from django.db import models
from common.base_models import BaseModel

class ImmersiveExperience(BaseModel):
    """
    Placeholder model for AR/VR and immersive cultural experiences.
    """
    title = models.CharField(max_length=255, help_text="Title of the immersive experience")
    description = models.TextField(help_text="Description of the immersive experience")
    media_url = models.URLField(null=True, blank=True, help_text="URL for the immersive AR/VR content")

    def __str__(self):
        return self.title

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\kreative\immersive\serializers.py ---
from rest_framework import serializers
from kreative.immersive.models import ImmersiveExperience

class ImmersiveExperienceSerializer(serializers.ModelSerializer):
    class Meta:
        model = ImmersiveExperience
        fields = [
            'id',
            'title',
            'description',
            'media_url',
            'created_at',
            'updated_at'
        ]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\kreative\immersive\urls.py ---
# apps/kreative/immersive/urls.py
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from kreative.immersive.views import ImmersiveExperienceViewSet

router = DefaultRouter()
router.register(r'immersive_experiences', ImmersiveExperienceViewSet)

urlpatterns = [
    path('', include(router.urls)),
]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\kreative\immersive\views.py ---
# apps/kreative/immersive/views.py

from rest_framework import viewsets, permissions
from kreative.immersive.models import ImmersiveExperience
from kreative.immersive.serializers import ImmersiveExperienceSerializer

class ImmersiveExperienceViewSet(viewsets.ModelViewSet):
    """
    ViewSet pour gérer les expériences immersives (AR/VR).
    Ce module est minimal et peut être étendu ultérieurement.
    """
    queryset = ImmersiveExperience.objects.all()
    serializer_class = ImmersiveExperienceSerializer
    permission_classes = [permissions.IsAuthenticated]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\kreative\kreativecommunity\admin.py ---
# apps/kreative/community/admin.py

from django.contrib import admin
from kreative.kreativecommunity.models import CommunityPost, PostComment

@admin.register(CommunityPost)
class CommunityPostAdmin(admin.ModelAdmin):
    list_display = ('title', 'posted_by', 'created_at')
    search_fields = ('title', 'content')
    ordering = ('-created_at',)
    
    fieldsets = (
        (None, {'fields': ('title', 'content')}),
        ('Informations', {'fields': ('posted_by',)}),
    )

@admin.register(PostComment)
class PostCommentAdmin(admin.ModelAdmin):
    list_display = ('post', 'commented_by', 'short_content', 'created_at')
    list_filter = ('post', 'commented_by')
    search_fields = ('content',)
    ordering = ('-created_at',)
    
    def short_content(self, obj):
        return (obj.content[:75] + '...') if len(obj.content) > 75 else obj.content
    short_content.short_description = "Contenu"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\kreative\kreativecommunity\apps.py ---
from django.apps import AppConfig

class KreativeCommunityConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'kreative.kreativecommunity'
    verbose_name = "Kreative Community"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\kreative\kreativecommunity\forms.py ---

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\kreative\kreativecommunity\models.py ---
"""
File: apps/kreative/kreative_community/models.py

Purpose:
Create models for community posts, reviews, ratings, and threaded comments related to art.
"""

from django.db import models
from common.base_models import BaseModel

class CommunityPost(BaseModel):
    """
    Represents a community post related to art.
    """
    title = models.CharField(max_length=255, help_text="Title of the post")
    content = models.TextField(help_text="Content of the post")
    posted_by = models.ForeignKey(
        "core.CustomUser",
        on_delete=models.CASCADE,
        related_name="community_posts",
        help_text="User who posted the community post"
    )

    def __str__(self):
        return self.title

class PostComment(BaseModel):
    """
    Represents a comment on a community post, supporting threaded replies.
    """
    post = models.ForeignKey(
        CommunityPost,
        on_delete=models.CASCADE,
        related_name="comments",
        help_text="The community post being commented on"
    )
    parent = models.ForeignKey(
        'self',
        on_delete=models.CASCADE,
        null=True,
        blank=True,
        related_name="replies",
        help_text="Parent comment for threaded replies"
    )
    content = models.TextField(help_text="Content of the comment")
    commented_by = models.ForeignKey(
        "core.CustomUser",
        on_delete=models.CASCADE,
        related_name="post_comments",
        help_text="User who made the comment"
    )

    def __str__(self):
        return f"Comment by {self.commented_by} on {self.post.title}"

class ArtworkReview(BaseModel):
    """
    Represents a review or rating for an artwork.
    """
    artwork = models.ForeignKey(
        "artworks.Artwork",
        on_delete=models.CASCADE,
        related_name="reviews",
        help_text="Artwork being reviewed"
    )
    reviewed_by = models.ForeignKey(
        "core.CustomUser",
        on_delete=models.CASCADE,
        related_name="artwork_reviews",
        help_text="User who reviewed the artwork"
    )
    rating = models.PositiveSmallIntegerField(help_text="Rating value (e.g., 1 to 5)")
    review_text = models.TextField(null=True, blank=True, help_text="Optional review text")

    def __str__(self):
        return f"Review for {self.artwork.title} by {self.reviewed_by}"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\kreative\kreativecommunity\serializers.py ---
from rest_framework import serializers
from kreative.kreativecommunity.models import CommunityPost, PostComment, ArtworkReview

class CommunityPostSerializer(serializers.ModelSerializer):
    class Meta:
        model = CommunityPost
        fields = [
            'id',
            'title',
            'content',
            'posted_by',
            'created_at',
            'updated_at'
        ]

class PostCommentSerializer(serializers.ModelSerializer):
    replies = serializers.SerializerMethodField()

    class Meta:
        model = PostComment
        fields = [
            'id',
            'post',
            'parent',
            'content',
            'commented_by',
            'created_at',
            'updated_at',
            'replies'
        ]

    def get_replies(self, obj):
        qs = obj.replies.all()
        return PostCommentSerializer(qs, many=True).data

class ArtworkReviewSerializer(serializers.ModelSerializer):
    class Meta:
        model = ArtworkReview
        fields = [
            'id',
            'artwork',
            'reviewed_by',
            'rating',
            'review_text',
            'created_at',
            'updated_at'
        ]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\kreative\kreativecommunity\urls.py ---
# apps/konnected/community/urls.py
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from konnected.konnectedcommunity.views import DiscussionThreadViewSet, CommentViewSet

router = DefaultRouter()
router.register(r'discussions', DiscussionThreadViewSet)
router.register(r'comments', CommentViewSet)

urlpatterns = [
    path('', include(router.urls)),
]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\kreative\kreativecommunity\views.py ---
# apps/konnected/konnectedcommunity/views.py

from rest_framework import viewsets, permissions
from konnected.konnectedcommunity.models import DiscussionThread, Comment
from konnected.konnectedcommunity.serializers import DiscussionThreadSerializer, CommentSerializer

class DiscussionThreadViewSet(viewsets.ModelViewSet):
    """
    ViewSet pour gérer les fils de discussion (forum, Q&A) dans le cadre éducatif.
    """
    queryset = DiscussionThread.objects.all()
    serializer_class = DiscussionThreadSerializer
    permission_classes = [permissions.IsAuthenticated]

class CommentViewSet(viewsets.ModelViewSet):
    """
    ViewSet pour gérer les commentaires sur les discussions.
    """
    queryset = Comment.objects.all()
    serializer_class = CommentSerializer
    permission_classes = [permissions.IsAuthenticated]
# apps/kreative/community/views.py

from rest_framework import viewsets, permissions
from kreative.kreativecommunity.models import CommunityPost, PostComment
from kreative.kreativecommunity.serializers import CommunityPostSerializer, PostCommentSerializer

class CommunityPostViewSet(viewsets.ModelViewSet):
    """
    ViewSet pour gérer les posts communautaires.
    Permet de créer, mettre à jour et supprimer des posts autour des arts.
    """
    queryset = CommunityPost.objects.all()
    serializer_class = CommunityPostSerializer
    permission_classes = [permissions.IsAuthenticated]

class PostCommentViewSet(viewsets.ModelViewSet):
    """
    ViewSet pour gérer les commentaires sur les posts communautaires.
    Permet de créer, mettre à jour et supprimer des commentaires.
    """
    queryset = PostComment.objects.all()
    serializer_class = PostCommentSerializer
    permission_classes = [permissions.IsAuthenticated]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\kreative\marketplace\admin.py ---
# apps/kreative/marketplace/admin.py

from django.contrib import admin
from kreative.marketplace.models import ArtistProfile, Commission, MarketplaceListing

@admin.register(ArtistProfile)
class ArtistProfileAdmin(admin.ModelAdmin):
    list_display = ('user', 'portfolio_url', 'created_at')
    search_fields = ('user__username', 'portfolio_url')
    ordering = ('-created_at',)

@admin.register(Commission)
class CommissionAdmin(admin.ModelAdmin):
    list_display = ('title', 'requested_by', 'status', 'budget', 'created_at')
    list_filter = ('status', 'requested_by')
    search_fields = ('title', 'description')
    ordering = ('-created_at',)
    
    actions = ['change_status']
    
    def change_status(self, request, queryset):
        new_status = request.POST.get('new_status')
        if new_status:
            updated = queryset.update(status=new_status)
            self.message_user(request, f"{updated} commission(s) mise(s) à jour avec le statut {new_status}.")
        else:
            self.message_user(request, "Veuillez spécifier un nouveau statut.", level='error')
    change_status.short_description = "Changer le statut des commissions sélectionnées"

@admin.register(MarketplaceListing)
class MarketplaceListingAdmin(admin.ModelAdmin):
    list_display = ('title', 'artist_profile', 'price', 'status', 'created_at')
    list_filter = ('status', 'artist_profile')
    search_fields = ('title', 'description')
    ordering = ('-created_at',)

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\kreative\marketplace\apps.py ---
from django.apps import AppConfig

class KreativeMarketplaceConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'kreative.marketplace'
    verbose_name = "Kreative Marketplace"

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\kreative\marketplace\forms.py ---

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\kreative\marketplace\models.py ---
"""
File: apps/kreative/kreative_marketplace/models.py

Purpose:
Develop models for managing commissions, artist profiles, and marketplace listings.
Optionally includes placeholders for payment or contract integration.
"""

from django.db import models
from common.base_models import BaseModel

class ArtistProfile(BaseModel):
    """
    Represents an artist's profile containing portfolio and biography details.
    """
    user = models.OneToOneField(
        "core.CustomUser",
        on_delete=models.CASCADE,
        related_name="artist_profile",
        help_text="Associated user for the artist profile"
    )
    biography = models.TextField(null=True, blank=True, help_text="Artist biography")
    portfolio_url = models.URLField(null=True, blank=True, help_text="URL to the artist's portfolio")
    metadata = models.JSONField(null=True, blank=True, help_text="Additional artist metadata")

    def __str__(self):
        return f"Artist Profile: {self.user.username}"

class Commission(BaseModel):
    """
    Represents a commission request for custom artwork.
    """
    STATUS_CHOICES = [
        ('requested', 'Requested'),
        ('in_progress', 'In Progress'),
        ('completed', 'Completed'),
        ('cancelled', 'Cancelled'),
    ]
    title = models.CharField(max_length=255, help_text="Title of the commission")
    description = models.TextField(help_text="Details of the commission requirements")
    budget = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True, help_text="Budget for the commission")
    requested_by = models.ForeignKey(
        "core.CustomUser",
        on_delete=models.CASCADE,
        related_name="commissions_requested",
        help_text="User requesting the commission"
    )
    assigned_to = models.ForeignKey(
        ArtistProfile,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="commissions_assigned",
        help_text="Artist assigned to the commission"
    )
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default="requested", help_text="Current status of the commission")
    # Placeholder for payment or contract integration
    contract_url = models.URLField(null=True, blank=True, help_text="URL for the commission contract or payment agreement")

    def __str__(self):
        return self.title

class MarketplaceListing(BaseModel):
    """
    Represents a marketplace listing for artworks available for sale or commission.
    """
    STATUS_CHOICES = [
        ('active', 'Active'),
        ('sold', 'Sold'),
        ('removed', 'Removed'),
    ]
    title = models.CharField(max_length=255, help_text="Title of the listing")
    description = models.TextField(help_text="Description of the listing")
    price = models.DecimalField(max_digits=10, decimal_places=2, help_text="Price for the artwork")
    image = models.ImageField(upload_to="marketplace_listings/", help_text="Image for the listing")
    artist_profile = models.ForeignKey(
        ArtistProfile,
        on_delete=models.CASCADE,
        related_name="marketplace_listings",
        help_text="Artist profile associated with this listing"
    )
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default="active", help_text="Listing status")
    # Placeholder for future payment system integration
    payment_details = models.JSONField(null=True, blank=True, help_text="Payment details or integration data")

    def __str__(self):
        return self.title

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\kreative\marketplace\serializers.py ---
from rest_framework import serializers
from kreative.marketplace.models import ArtistProfile, Commission, MarketplaceListing

class ArtistProfileSerializer(serializers.ModelSerializer):
    user = serializers.PrimaryKeyRelatedField(read_only=True)

    class Meta:
        model = ArtistProfile
        fields = [
            'id',
            'user',
            'biography',
            'portfolio_url',
            'metadata',
            'created_at',
            'updated_at'
        ]

class CommissionSerializer(serializers.ModelSerializer):
    requested_by = serializers.PrimaryKeyRelatedField(read_only=True)
    assigned_to = serializers.PrimaryKeyRelatedField(read_only=True)

    class Meta:
        model = Commission
        fields = [
            'id',
            'title',
            'description',
            'budget',
            'requested_by',
            'assigned_to',
            'status',
            'contract_url',
            'created_at',
            'updated_at'
        ]

class MarketplaceListingSerializer(serializers.ModelSerializer):
    artist_profile = ArtistProfileSerializer(read_only=True)

    class Meta:
        model = MarketplaceListing
        fields = [
            'id',
            'title',
            'description',
            'price',
            'image',
            'artist_profile',
            'status',
            'payment_details',
            'created_at',
            'updated_at'
        ]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\kreative\marketplace\urls.py ---
# apps/kreative/marketplace/urls.py
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from kreative.marketplace.views import ArtistProfileViewSet, CommissionViewSet, MarketplaceListingViewSet

router = DefaultRouter()
router.register(r'artist_profiles', ArtistProfileViewSet)
router.register(r'commissions', CommissionViewSet)
router.register(r'marketplace_listings', MarketplaceListingViewSet)

urlpatterns = [
    path('', include(router.urls)),
]

================================================================================

# --- Contents of: C:\MonCode\KonnaxionV4\apps\kreative\marketplace\views.py ---
# apps/kreative/marketplace/views.py

from rest_framework import viewsets, permissions, status
from rest_framework.decorators import action
from rest_framework.response import Response
from kreative.marketplace.models import ArtistProfile, Commission, MarketplaceListing
from kreative.marketplace.serializers import (
    ArtistProfileSerializer,
    CommissionSerializer,
    MarketplaceListingSerializer
)

class ArtistProfileViewSet(viewsets.ModelViewSet):
    """
    ViewSet pour gérer les profils d'artistes.
    Permet aux artistes de gérer leur profil et leur portfolio.
    """
    queryset = ArtistProfile.objects.all()
    serializer_class = ArtistProfileSerializer
    permission_classes = [permissions.IsAuthenticated]

class CommissionViewSet(viewsets.ModelViewSet):
    """
    ViewSet pour gérer les commissions artistiques.
    Permet de créer, mettre à jour et suivre les demandes de commissions.
    """
    queryset = Commission.objects.all()
    serializer_class = CommissionSerializer
    permission_classes = [permissions.IsAuthenticated]

    @action(detail=True, methods=['post'], permission_classes=[permissions.IsAuthenticated])
    def update_status(self, request, pk=None):
        """
        Action personnalisée pour mettre à jour le statut d'une commission.
        Par exemple, passer de 'requested' à 'in_progress' ou 'completed'.
        """
        commission = self.get_object()
        new_status = request.data.get('status')
        if not new_status:
            return Response({"error": "Le champ 'status' est requis."},
                            status=status.HTTP_400_BAD_REQUEST)
        commission.status = new_status
        commission.save()
        return Response(self.get_serializer(commission).data)

class MarketplaceListingViewSet(viewsets.ModelViewSet):
    """
    ViewSet pour gérer les annonces du marketplace.
    Permet de créer, mettre à jour et supprimer des annonces d'œuvres ou de commissions.
    """
    queryset = MarketplaceListing.objects.all()
    serializer_class = MarketplaceListingSerializer
    permission_classes = [permissions.IsAuthenticated]

================================================================================
